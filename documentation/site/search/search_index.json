{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Introduction This is a library for \"ticking\" statemachines, it is originally based upon the Yasmin library, but is substantially changed TODO Completely decouple from yasmin? nothing substantial is left and would be easy to completely decouple from Yasmin. Certainly in practice, it is used completely differently. Each TickingState (see API for detailed definition) is defined by the following methods: entry(self,blackboard) : executed when the state is entered doo(self,blackboard) : execute while the state is running. The state can take a longer time but should regularly yield by returning TICKING. exit(self) : is execute when the state exits, note that it does not has the blackboard as argument. Will even be called when the other methods return an exception. reset(self) : Resets the state (i.e. calls exit() when appropriate and ensures that the next time, entry() will be called) --- title: Internal workings of TickingState --- stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white classDef centerClass text-align:center entry --> doo : returns <br>CONTINUE or TICK doo --> doo: returns<br>TICK doo --> exit : returns not TICK entry -->exit: returns <br>not TICK or CONTINUE exit --> entry : exit() finished <br> or reset() called doo --> exit : reset() called entry: calls entry()<br>if TICK return TICK<br>if exception return ABORT doo: calls doo()<br> if TICK return TICK <br>if exception return ABORT exit: calls exit()<br> return outcome<br>if exception return ABORT class entry centerClass When using the state one calls it with the () operator. This calls then the execute() method that calls the entry,doo,exit methods appropriately, according to the figure above. The visitor pattern is used to be able to generically travers the hierarchy of states. the accept method of a TickingState calls the visitor appropriately. Visitor is defined here Summary of states and state-machines For full specification, see the API-documentation. Sometimes states have underlying states, e.g. a state-machine or a sequence. Typically they can be specfied in two ways: a list of children in the constructor. This is handy when the substates are also simple to construct. If there is only one underlying state, the constructor argument is typically called state , if there are multiple underlying states, the constructor argument is typically called children . by subclassing the state (e.g. Sequence), and calling add_state() in the constructor of this subclass. This is handy when the definition of the substates is a bit more complex. In some cases, more information needs to be given and only the add_state approach is applicable (e.g. TickingStateMachine). The state-machine state TickingStateMachine implements a basic state machine. You can add nodes using add_state . In this call you also specify the transitions between states. These transitions are specified by mapping an outcome of the state to the name of one of the states in the state machine. The constructor takes a ( instance ) name of the state machine, its allowable outcomes and two optional callback functions transitioncb and statecb . Default implementations of the callbacks are described in default|_transition_cb and default_statecb . Behavior-tree like states The most important behavior-tree like states are Sequence , Fallback , ConcurrentSequence , ConcurrentFallback , and Repeat The main difference is that for a typical behavior-tree implementation the outcomes can only be RUNNING, SUCCESS or FAILURE. Here, there can be more types of outcome. The mapping to traditional behavior trees is explained below, detailed behavior is documented in the diagrams in the API-documentation. Fallback (or Any(success) ): Implements a behaviortree-like Fallback node (concurrently executed): other outcome is success CANCEL outcome is failure TICKING outcome is running Finishes if any has success. Success is defined by an outcome different from CANCEL. In other words, success can be differentiated by different outcomes. Sequence (or All(success) ). Implements a behaviortree-like Sequence node (concurrently executed): SUCCEED outcome is success, any other outcome is failure TICKING outcome is running Finishes if all have success. Success is defined by an outcome SUCCEED. In other words, failure can be differentiated by different outcomes. ConcurrentSequence and ConcurrentFallback are basically the same as Sequence and Fallback but execute concurrently: at each tick they go to their complete list of states and follow the logic of sequence or fallback. e.g. in a ConcurrentSequence the states are executed concurrently, but within one tick, they are executed in the order specified. Concurrent executes also its children concurrently (calling them in sequence for each tick). Concurrent stops executing when any child returns any outcome different from TICKING. See API for description fo detailed behavior. The Repeat state has one underlying state and repeats this state for a given number of times. Related to conditions waitFor waits until a condition is satisfied. This condition is given by a callback. Note that this callback can be defined using Python's lambda WaitForever waits forever, you probably want something to be running in parallel with this. While continues to execute the underlying state while checking the given condition. It finishes with CANCEL when the condition returns false, it finishes also when the underlying state finishes and returns the outcome of the underlying state. Related to output Message is a state to quickly return send message to the log. Its arguments are either a string or either a callback function. Since the string is specified at construction time, the callback function is handy when you want to return something depending on the actual state while running. Python's lambda could be useful to specify the callback. LogBlackboard logs the blackboard or a part of the blackboard. The location to log is given by a list of strings. Example: LogBlackboard|([\"output\",\"move_home\"]) Logs the content of the blackboard under blackboard[\"output][\"move_home\"] Related to timing TimedWait waits for the given duration and returns SUCCEED. TimedRepeat repeats the underlying state for a given number of time. The time between two repetitions is specified. Timeout executes the underlying state at long as its outcome is TICKING. It finishes when the outcome is not ticking and returns this outcome. It also finishes when the given duration is exceeded and returns TIMEOUT. Related to ROS 2 services, life cycle and topics To manage file locations in a ROS2 environment a function expand_ref is provided that expands references to ROS2 packages (or more preciselly ament packages) (using $[packagename] ) or environmental variables (using ${environmental_variable} ) ServiceClient creates a TickingState that calls a ROS2 service and generates an outcome when the service returns back. While waiting, it continues to tick. Subclasses need to implement two methods fill_in_request to fill in the service request, most probably using information from the blackboard, and process_result to process the result from the service request, most probably putting some information in the blackboard. LifeCycle manages the lifecycle of some other ROS2 node. The node is constructed with service_name, transition (see below), timeout and the transition is requested during execution of the state. See below for a simplified view of this lifecycle (transition states not included): stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> unconfigured unconfigured --> inactive : CONFIGURE inactive --> active : ACTIVATE inactive --> unconfigured : CLEANUP inactive --> finalized : INACTIVE_SHUTDOWN active --> inactive : DEACTIVATE active --> finalized : ACTIVE_SHUTDOWN unconfigured --> finalized : UNCONFIGURED_SHUTDOWN These are the transtions that can be passed to a LifeCycle state: python class Transition(Enum): CONFIGURE = 1 CLEANUP = 2 ACTIVATE = 3 DEACTIVATE = 4 UNCONFIGURED_SHUTDOWN = 5 INACTIVE_SHUTDOWN = 6 ACTIVE_SHUTDOWN = 7 Related to eTaSL Defining your own states To implement a TickingState, you have to implement: def entry(self, blackboard: Blackboard) -> str called when execute() is called for the first time. returns an outcome but has one additional outcome CONTINUE that indicates its preference to directly call doo() after its return, without a tick. def doo(self, blackboard: Blackboard) -> str called for the duration of the task, as long as you return TICKING def exit(self) -> str : should call return super().exit() at the end, is guaranteed to be called after the last time that execute() was called. def reset(self)->None: should call super().exit() at the end: to reset the state and its children . def accept(self, visitor:Visitor) calls pre on the visitor, calls accept(visitor) on all its children, and then calls post on the visitor. To facilitate the definition of tickingStates, you can use Python generators , for this the Generator class is defined. This allows to define TickingStates using a python generator method co_execute(self, blackboard:Blackboard) . This routine has to regularly yield control using a yield <outcom> statement. This makes it easy to specify a TickingState. Keep in mind that the reset and accept methods still need to be defined when the state has children (otherwise the default implementations are sufficient) Warning Forgetting to implement these methods can lead to silent failures. Even worse, the state will work the first time, but not the second time. Warning Outside code that repeately calls a state-machine has to call reset itself before calling the state-machine. For the common use cases of a Generator with one child state and a Generator with a list of child states implementations are provided that implement reset and accept for you: GeneratorWithState and GeneratorWithList are generic implementations to be uses to subclass from while implementing states with one or multiple underlying states. Recommendation Look a a few implementations such as WaitFor , Repeat , Concurrent","title":"Home"},{"location":"#home","text":"","title":"Home"},{"location":"#introduction","text":"This is a library for \"ticking\" statemachines, it is originally based upon the Yasmin library, but is substantially changed TODO Completely decouple from yasmin? nothing substantial is left and would be easy to completely decouple from Yasmin. Certainly in practice, it is used completely differently. Each TickingState (see API for detailed definition) is defined by the following methods: entry(self,blackboard) : executed when the state is entered doo(self,blackboard) : execute while the state is running. The state can take a longer time but should regularly yield by returning TICKING. exit(self) : is execute when the state exits, note that it does not has the blackboard as argument. Will even be called when the other methods return an exception. reset(self) : Resets the state (i.e. calls exit() when appropriate and ensures that the next time, entry() will be called) --- title: Internal workings of TickingState --- stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white classDef centerClass text-align:center entry --> doo : returns <br>CONTINUE or TICK doo --> doo: returns<br>TICK doo --> exit : returns not TICK entry -->exit: returns <br>not TICK or CONTINUE exit --> entry : exit() finished <br> or reset() called doo --> exit : reset() called entry: calls entry()<br>if TICK return TICK<br>if exception return ABORT doo: calls doo()<br> if TICK return TICK <br>if exception return ABORT exit: calls exit()<br> return outcome<br>if exception return ABORT class entry centerClass When using the state one calls it with the () operator. This calls then the execute() method that calls the entry,doo,exit methods appropriately, according to the figure above. The visitor pattern is used to be able to generically travers the hierarchy of states. the accept method of a TickingState calls the visitor appropriately. Visitor is defined here","title":"Introduction"},{"location":"#summary-of-states-and-state-machines","text":"For full specification, see the API-documentation. Sometimes states have underlying states, e.g. a state-machine or a sequence. Typically they can be specfied in two ways: a list of children in the constructor. This is handy when the substates are also simple to construct. If there is only one underlying state, the constructor argument is typically called state , if there are multiple underlying states, the constructor argument is typically called children . by subclassing the state (e.g. Sequence), and calling add_state() in the constructor of this subclass. This is handy when the definition of the substates is a bit more complex. In some cases, more information needs to be given and only the add_state approach is applicable (e.g. TickingStateMachine).","title":"Summary of states and state-machines"},{"location":"#the-state-machine-state","text":"TickingStateMachine implements a basic state machine. You can add nodes using add_state . In this call you also specify the transitions between states. These transitions are specified by mapping an outcome of the state to the name of one of the states in the state machine. The constructor takes a ( instance ) name of the state machine, its allowable outcomes and two optional callback functions transitioncb and statecb . Default implementations of the callbacks are described in default|_transition_cb and default_statecb .","title":"The state-machine state"},{"location":"#behavior-tree-like-states","text":"The most important behavior-tree like states are Sequence , Fallback , ConcurrentSequence , ConcurrentFallback , and Repeat The main difference is that for a typical behavior-tree implementation the outcomes can only be RUNNING, SUCCESS or FAILURE. Here, there can be more types of outcome. The mapping to traditional behavior trees is explained below, detailed behavior is documented in the diagrams in the API-documentation. Fallback (or Any(success) ): Implements a behaviortree-like Fallback node (concurrently executed): other outcome is success CANCEL outcome is failure TICKING outcome is running Finishes if any has success. Success is defined by an outcome different from CANCEL. In other words, success can be differentiated by different outcomes. Sequence (or All(success) ). Implements a behaviortree-like Sequence node (concurrently executed): SUCCEED outcome is success, any other outcome is failure TICKING outcome is running Finishes if all have success. Success is defined by an outcome SUCCEED. In other words, failure can be differentiated by different outcomes. ConcurrentSequence and ConcurrentFallback are basically the same as Sequence and Fallback but execute concurrently: at each tick they go to their complete list of states and follow the logic of sequence or fallback. e.g. in a ConcurrentSequence the states are executed concurrently, but within one tick, they are executed in the order specified. Concurrent executes also its children concurrently (calling them in sequence for each tick). Concurrent stops executing when any child returns any outcome different from TICKING. See API for description fo detailed behavior. The Repeat state has one underlying state and repeats this state for a given number of times.","title":"Behavior-tree like states"},{"location":"#related-to-conditions","text":"waitFor waits until a condition is satisfied. This condition is given by a callback. Note that this callback can be defined using Python's lambda WaitForever waits forever, you probably want something to be running in parallel with this. While continues to execute the underlying state while checking the given condition. It finishes with CANCEL when the condition returns false, it finishes also when the underlying state finishes and returns the outcome of the underlying state.","title":"Related to conditions"},{"location":"#related-to-output","text":"Message is a state to quickly return send message to the log. Its arguments are either a string or either a callback function. Since the string is specified at construction time, the callback function is handy when you want to return something depending on the actual state while running. Python's lambda could be useful to specify the callback. LogBlackboard logs the blackboard or a part of the blackboard. The location to log is given by a list of strings. Example: LogBlackboard|([\"output\",\"move_home\"]) Logs the content of the blackboard under blackboard[\"output][\"move_home\"]","title":"Related to output"},{"location":"#related-to-timing","text":"TimedWait waits for the given duration and returns SUCCEED. TimedRepeat repeats the underlying state for a given number of time. The time between two repetitions is specified. Timeout executes the underlying state at long as its outcome is TICKING. It finishes when the outcome is not ticking and returns this outcome. It also finishes when the given duration is exceeded and returns TIMEOUT.","title":"Related to timing"},{"location":"#related-to-ros-2-services-life-cycle-and-topics","text":"To manage file locations in a ROS2 environment a function expand_ref is provided that expands references to ROS2 packages (or more preciselly ament packages) (using $[packagename] ) or environmental variables (using ${environmental_variable} ) ServiceClient creates a TickingState that calls a ROS2 service and generates an outcome when the service returns back. While waiting, it continues to tick. Subclasses need to implement two methods fill_in_request to fill in the service request, most probably using information from the blackboard, and process_result to process the result from the service request, most probably putting some information in the blackboard. LifeCycle manages the lifecycle of some other ROS2 node. The node is constructed with service_name, transition (see below), timeout and the transition is requested during execution of the state. See below for a simplified view of this lifecycle (transition states not included): stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> unconfigured unconfigured --> inactive : CONFIGURE inactive --> active : ACTIVATE inactive --> unconfigured : CLEANUP inactive --> finalized : INACTIVE_SHUTDOWN active --> inactive : DEACTIVATE active --> finalized : ACTIVE_SHUTDOWN unconfigured --> finalized : UNCONFIGURED_SHUTDOWN These are the transtions that can be passed to a LifeCycle state: python class Transition(Enum): CONFIGURE = 1 CLEANUP = 2 ACTIVATE = 3 DEACTIVATE = 4 UNCONFIGURED_SHUTDOWN = 5 INACTIVE_SHUTDOWN = 6 ACTIVE_SHUTDOWN = 7","title":"Related to ROS 2 services, life cycle and topics"},{"location":"#related-to-etasl","text":"","title":"Related to eTaSL"},{"location":"#defining-your-own-states","text":"To implement a TickingState, you have to implement: def entry(self, blackboard: Blackboard) -> str called when execute() is called for the first time. returns an outcome but has one additional outcome CONTINUE that indicates its preference to directly call doo() after its return, without a tick. def doo(self, blackboard: Blackboard) -> str called for the duration of the task, as long as you return TICKING def exit(self) -> str : should call return super().exit() at the end, is guaranteed to be called after the last time that execute() was called. def reset(self)->None: should call super().exit() at the end: to reset the state and its children . def accept(self, visitor:Visitor) calls pre on the visitor, calls accept(visitor) on all its children, and then calls post on the visitor. To facilitate the definition of tickingStates, you can use Python generators , for this the Generator class is defined. This allows to define TickingStates using a python generator method co_execute(self, blackboard:Blackboard) . This routine has to regularly yield control using a yield <outcom> statement. This makes it easy to specify a TickingState. Keep in mind that the reset and accept methods still need to be defined when the state has children (otherwise the default implementations are sufficient) Warning Forgetting to implement these methods can lead to silent failures. Even worse, the state will work the first time, but not the second time. Warning Outside code that repeately calls a state-machine has to call reset itself before calling the state-machine. For the common use cases of a Generator with one child state and a Generator with a list of child states implementations are provided that implement reset and accept for you: GeneratorWithState and GeneratorWithList are generic implementations to be uses to subclass from while implementing states with one or multiple underlying states. Recommendation Look a a few implementations such as WaitFor , Repeat , Concurrent","title":"Defining your own states"},{"location":"TODO/","text":"TODO list Investigate the difference between reset() and cancel_state(). How does the original yasmin code handles concurrent access? clean up the outcomes list uniform treatment of names generating graphviz representation of state machine. How do we model this: So, for an eTaSL state: ConcurrentFallback( EventTopic, OutputTopic, Sequence(Activate, Wait) ) But for EventTopic this means that the topics have to be with a durability = transient local because the topic can be created late. Could we tune the qos parameters to be transient local for a small time, i.e. 0.1 (or even smaller) ? relatively short Lifespan and transient local durability are probably the best.","title":"Todo list"},{"location":"TODO/#todo-list","text":"Investigate the difference between reset() and cancel_state(). How does the original yasmin code handles concurrent access? clean up the outcomes list uniform treatment of names generating graphviz representation of state machine.","title":"TODO list"},{"location":"TODO/#how-do-we-model-this","text":"So, for an eTaSL state: ConcurrentFallback( EventTopic, OutputTopic, Sequence(Activate, Wait) ) But for EventTopic this means that the topics have to be with a durability = transient local because the topic can be created late. Could we tune the qos parameters to be transient local for a small time, i.e. 0.1 (or even smaller) ? relatively short Lifespan and transient local durability are probably the best.","title":"How do we model this:"},{"location":"about/","text":"About Erwin Aertbeli\u00ebn (c) 2024 LGPL-3.0-only license, see LICENSE file in main directory.","title":"About"},{"location":"about/#about","text":"Erwin Aertbeli\u00ebn (c) 2024 LGPL-3.0-only license, see LICENSE file in main directory.","title":"About"},{"location":"actionserver/","text":"Action Server Interface The following class implements an action server that respond to actions with idl: # only from the perspective of the state-machine # we can have generic handling of the parameters. # (perhaps needing adaptation of your handling of eTaSL parameters, such that they can also take parameters that are set beforehand # in the blackboard, i.e. not overwritten by defaults if they exist) # # goal string task string parameters --- # result string outcome string parameters --- # feedback string state string parameters This interface is generic and applies to all state machines that are controlled: goal task is a label that indicates which state-machine needs to be executed parameters is a string with JSON describing the parameters of the task. These parameters will be put in BeTFSM's blackboard for use within the statemachine. Optionally these parameters can be validated using a JSON-Schema result outcome is cancel or success parameters is everything what is in blackboard[\"result\"] encoded into a JSON string. feedback state is the label of the currently active state of state-machine. parameters is everything what is in blackboard[\"feedback\"] encoded into a JSON string Server The state machine is run in the EXECUTING state of the above figure from the ROS2 documentation. The goal_callback checks whether the task exists in the dictionary of state machines and optionally validates the input parameters of the task using a schema. The action server is implemented in the BeTFSMActionServer described below. The tasks that the action server can react to are described by a Dictionary that maps the name of the task to an instance of TickingState (a state machine).. Sequence diagram of interactions: sequenceDiagram participant ActionClient participant ActionServer participant Execute activate ActionClient ActionClient ->> ActionServer: goal_request activate ActionServer ActionServer --) ActionClient: goal_response (accept only 1 simult.action) ActionServer ->> Execute: handle_goal deactivate ActionServer activate Execute ActionClient ->> ActionServer: get_result activate ActionServer Execute ->> Blackboard: set goal_handle Execute ->> Blackboard: set and validate input_parameters Note over Execute: state machine for task running loop over state machine until outcome!=TICKING Execute ->> Blackboard : get info from blackboard<br>always react at some point in time <br>to goal_handle.is_cancel_request<br>Generate feedback messages end Note over Execute: state machine stopped Execute ->> Blackboard : get result.outcome and <br> result.parameters from blackboard Execute ->> ActionServer: succeed() or cancel() <br> construct result msg deactivate Execute ActionServer--) ActionClient: result_request deactivate ActionServer deactivate ActionClient To specify a schema to validate the parameters, add input_parameters_schema member to the TickingState with the schena in python format (i.e. using json.loads(\"...\" ) betfsm.betfsm_action_server.BeTFSMActionServer Action server that processes BeTFSM tasks one goal at a time. Each action starts state machine __init__ ( blackboard , statemachines , frequency = 100 , node = None ) Parameters: blackboard \u2013 blackboard to use when responding to actions. statemachines \u2013 a list of task names and state machines. frequency ( int , default: 100 ) \u2013 frequency at which to run the state machine once an action is received. node ( Node , default: None ) \u2013 ROS2 node for the action server, if None, the singleton BeTFSMNode.get_instance() will be used. cancel_callback ( goal ) Accept or reject a client request to cancel an action. execute_callback ( goal_handle ) Execute the goal. goal_callback ( goal_request ) called to accept or reject a client request. handle_accepted_callback ( goal_handle ) handle an accepted action Giving intermediate feedback betfsm.betfsm_action_server.FeedbackState Bases: TickingState __init__ ( name , state , cb ) A ticking state that uses a callback function to publish to the feedback topic of an action. Parameters: name ( str ) \u2013 name of the instance state ( str ) \u2013 is passed as the state field of the feedback message cb ( Dict ) \u2013 callback function that returns a dictionary, possibly hierarchical that will be mapped to the parameters string field of the feedback message. The callback has signature def cb(bbb) -> Dict Checking for cancelation Actions can be canceled and our action server and state machines need to react appropriately. Interaction diagram example_action_server The example_action_server example shows a case where we continuously check for an action and when an cancelation is detected go out of the state machines and perform a shutdown procedure. The following class is used for this purpose: betfsm.betfsm_action_server.WhileNotCanceled Bases: GeneratorWithState Runs underlying state as long as not canceled. Returns outcome of state, yields CANCEL if there is a client side cancel request. __init__ ( name , state ) Runs underlying state as long as not canceled. Returns outcome of state yields CANCEL if there is a client side cancel request. Parameters: name ( str ) \u2013 name of this state state ( TickingState ) \u2013 underlying state This class runs its underlying state and has transitions that depend on the outcome of the underlying state or on cancelation requests. With this we can build a simple statemachine to implement what should happen when cancel is requested: class CheckingCancelAndShutdown(TickingStateMachine): def __init__(self,name:str,state:TickingState,srv_name:str=\"/etasl_node\",timeout:Duration = Duration(seconds=1.0), node : Node = None): # execute in sequence but don't care about ABORT, only way to fail is TIMEOUT super().__init__(name,[CANCEL,SUCCEED]) self.add_state(state=WhileNotCanceled(\"while_not_canceled\",state), transitions={CANCEL:\"DEACTIVATE_ETASL\",SUCCEED:SUCCEED, TIMEOUT:\"DEACTIVATE_ETASL\"}) self.add_state(state=LifeCycle(\"DEACTIVATE_ETASL\",srv_name,Transition.DEACTIVATE,timeout,node), transitions={SUCCEED: \"CLEANUP_ETASL\", ABORT: \"CLEANUP_ETASL\", TIMEOUT:\"CLEANUP_ETASL\"} ) self.add_state( state=LifeCycle(\"CLEANUP_ETASL\",srv_name,Transition.CLEANUP,timeout,node), transitions={SUCCEED: CANCEL, ABORT: CANCEL,TIMEOUT: CANCEL} ) example_action_server2 The example_action_server2 describes another approach where there is only a check for cancelation at specific locations of the state machine(s). The following TickingState is used for this purpose: betfsm.betfsm_action_server.CheckForCanceledAction Bases: Generator Checks whether the Action that is running has received a cancel request. __init__ ( name ) Checks whether the Action that is running has received a cancel request. Returns SUCCEED if nothing received, returns CANCEL if something received Parameters: name ( str ) \u2013 name of this state","title":"Action server"},{"location":"actionserver/#action-server","text":"","title":"Action Server"},{"location":"actionserver/#interface","text":"The following class implements an action server that respond to actions with idl: # only from the perspective of the state-machine # we can have generic handling of the parameters. # (perhaps needing adaptation of your handling of eTaSL parameters, such that they can also take parameters that are set beforehand # in the blackboard, i.e. not overwritten by defaults if they exist) # # goal string task string parameters --- # result string outcome string parameters --- # feedback string state string parameters This interface is generic and applies to all state machines that are controlled: goal task is a label that indicates which state-machine needs to be executed parameters is a string with JSON describing the parameters of the task. These parameters will be put in BeTFSM's blackboard for use within the statemachine. Optionally these parameters can be validated using a JSON-Schema result outcome is cancel or success parameters is everything what is in blackboard[\"result\"] encoded into a JSON string. feedback state is the label of the currently active state of state-machine. parameters is everything what is in blackboard[\"feedback\"] encoded into a JSON string","title":"Interface"},{"location":"actionserver/#server","text":"The state machine is run in the EXECUTING state of the above figure from the ROS2 documentation. The goal_callback checks whether the task exists in the dictionary of state machines and optionally validates the input parameters of the task using a schema. The action server is implemented in the BeTFSMActionServer described below. The tasks that the action server can react to are described by a Dictionary that maps the name of the task to an instance of TickingState (a state machine).. Sequence diagram of interactions: sequenceDiagram participant ActionClient participant ActionServer participant Execute activate ActionClient ActionClient ->> ActionServer: goal_request activate ActionServer ActionServer --) ActionClient: goal_response (accept only 1 simult.action) ActionServer ->> Execute: handle_goal deactivate ActionServer activate Execute ActionClient ->> ActionServer: get_result activate ActionServer Execute ->> Blackboard: set goal_handle Execute ->> Blackboard: set and validate input_parameters Note over Execute: state machine for task running loop over state machine until outcome!=TICKING Execute ->> Blackboard : get info from blackboard<br>always react at some point in time <br>to goal_handle.is_cancel_request<br>Generate feedback messages end Note over Execute: state machine stopped Execute ->> Blackboard : get result.outcome and <br> result.parameters from blackboard Execute ->> ActionServer: succeed() or cancel() <br> construct result msg deactivate Execute ActionServer--) ActionClient: result_request deactivate ActionServer deactivate ActionClient To specify a schema to validate the parameters, add input_parameters_schema member to the TickingState with the schena in python format (i.e. using json.loads(\"...\" )","title":"Server"},{"location":"actionserver/#betfsm.betfsm_action_server.BeTFSMActionServer","text":"Action server that processes BeTFSM tasks one goal at a time. Each action starts state machine","title":"BeTFSMActionServer"},{"location":"actionserver/#betfsm.betfsm_action_server.BeTFSMActionServer.__init__","text":"Parameters: blackboard \u2013 blackboard to use when responding to actions. statemachines \u2013 a list of task names and state machines. frequency ( int , default: 100 ) \u2013 frequency at which to run the state machine once an action is received. node ( Node , default: None ) \u2013 ROS2 node for the action server, if None, the singleton BeTFSMNode.get_instance() will be used.","title":"__init__"},{"location":"actionserver/#betfsm.betfsm_action_server.BeTFSMActionServer.cancel_callback","text":"Accept or reject a client request to cancel an action.","title":"cancel_callback"},{"location":"actionserver/#betfsm.betfsm_action_server.BeTFSMActionServer.execute_callback","text":"Execute the goal.","title":"execute_callback"},{"location":"actionserver/#betfsm.betfsm_action_server.BeTFSMActionServer.goal_callback","text":"called to accept or reject a client request.","title":"goal_callback"},{"location":"actionserver/#betfsm.betfsm_action_server.BeTFSMActionServer.handle_accepted_callback","text":"handle an accepted action","title":"handle_accepted_callback"},{"location":"actionserver/#giving-intermediate-feedback","text":"","title":"Giving intermediate feedback"},{"location":"actionserver/#betfsm.betfsm_action_server.FeedbackState","text":"Bases: TickingState","title":"FeedbackState"},{"location":"actionserver/#betfsm.betfsm_action_server.FeedbackState.__init__","text":"A ticking state that uses a callback function to publish to the feedback topic of an action. Parameters: name ( str ) \u2013 name of the instance state ( str ) \u2013 is passed as the state field of the feedback message cb ( Dict ) \u2013 callback function that returns a dictionary, possibly hierarchical that will be mapped to the parameters string field of the feedback message. The callback has signature def cb(bbb) -> Dict","title":"__init__"},{"location":"actionserver/#checking-for-cancelation","text":"Actions can be canceled and our action server and state machines need to react appropriately.","title":"Checking for cancelation"},{"location":"actionserver/#interaction-diagram","text":"","title":"Interaction diagram"},{"location":"actionserver/#example_action_server","text":"The example_action_server example shows a case where we continuously check for an action and when an cancelation is detected go out of the state machines and perform a shutdown procedure. The following class is used for this purpose:","title":"example_action_server"},{"location":"actionserver/#betfsm.betfsm_action_server.WhileNotCanceled","text":"Bases: GeneratorWithState Runs underlying state as long as not canceled. Returns outcome of state, yields CANCEL if there is a client side cancel request.","title":"WhileNotCanceled"},{"location":"actionserver/#betfsm.betfsm_action_server.WhileNotCanceled.__init__","text":"Runs underlying state as long as not canceled. Returns outcome of state yields CANCEL if there is a client side cancel request. Parameters: name ( str ) \u2013 name of this state state ( TickingState ) \u2013 underlying state This class runs its underlying state and has transitions that depend on the outcome of the underlying state or on cancelation requests. With this we can build a simple statemachine to implement what should happen when cancel is requested: class CheckingCancelAndShutdown(TickingStateMachine): def __init__(self,name:str,state:TickingState,srv_name:str=\"/etasl_node\",timeout:Duration = Duration(seconds=1.0), node : Node = None): # execute in sequence but don't care about ABORT, only way to fail is TIMEOUT super().__init__(name,[CANCEL,SUCCEED]) self.add_state(state=WhileNotCanceled(\"while_not_canceled\",state), transitions={CANCEL:\"DEACTIVATE_ETASL\",SUCCEED:SUCCEED, TIMEOUT:\"DEACTIVATE_ETASL\"}) self.add_state(state=LifeCycle(\"DEACTIVATE_ETASL\",srv_name,Transition.DEACTIVATE,timeout,node), transitions={SUCCEED: \"CLEANUP_ETASL\", ABORT: \"CLEANUP_ETASL\", TIMEOUT:\"CLEANUP_ETASL\"} ) self.add_state( state=LifeCycle(\"CLEANUP_ETASL\",srv_name,Transition.CLEANUP,timeout,node), transitions={SUCCEED: CANCEL, ABORT: CANCEL,TIMEOUT: CANCEL} )","title":"__init__"},{"location":"actionserver/#example_action_server2","text":"The example_action_server2 describes another approach where there is only a check for cancelation at specific locations of the state machine(s). The following TickingState is used for this purpose:","title":"example_action_server2"},{"location":"actionserver/#betfsm.betfsm_action_server.CheckForCanceledAction","text":"Bases: Generator Checks whether the Action that is running has received a cancel request.","title":"CheckForCanceledAction"},{"location":"actionserver/#betfsm.betfsm_action_server.CheckForCanceledAction.__init__","text":"Checks whether the Action that is running has received a cancel request. Returns SUCCEED if nothing received, returns CANCEL if something received Parameters: name ( str ) \u2013 name of this state","title":"__init__"},{"location":"adapt/","text":"betfsm.betfsm.Adapt Bases: GeneratorWithState __init__ ( name , state , transitions = []) Adapts the outcome of a state using a transition table Parameters: name ( str ) \u2013 instance name state ( TickingState ) \u2013 state to be adapted transitions \u2013 a dictionary that maps outcomes of state to their new values. If the outcome is not present in the dictionary, it is returned unchanged.","title":"Adapt"},{"location":"adapt/#betfsm.betfsm.Adapt","text":"Bases: GeneratorWithState","title":"Adapt"},{"location":"adapt/#betfsm.betfsm.Adapt.__init__","text":"Adapts the outcome of a state using a transition table Parameters: name ( str ) \u2013 instance name state ( TickingState ) \u2013 state to be adapted transitions \u2013 a dictionary that maps outcomes of state to their new values. If the outcome is not present in the dictionary, it is returned unchanged.","title":"__init__"},{"location":"compute/","text":"betfsm.betfsm.Compute Bases: Generator __init__ ( name , location , cb ) State that performs some computations using a callback function and places the results in a predetermined location in the blackboard. Parameters: name ( str ) \u2013 name of this node location ( List [ str ] ) \u2013 location in the blackboard, given as a list of strings. Should point to a dictionary. cb ( Callable ) \u2013 callback function with signature def cb(blackboard)->dict . The dictionary contents will be inserted in the given location","title":"Compute"},{"location":"compute/#betfsm.betfsm.Compute","text":"Bases: Generator","title":"Compute"},{"location":"compute/#betfsm.betfsm.Compute.__init__","text":"State that performs some computations using a callback function and places the results in a predetermined location in the blackboard. Parameters: name ( str ) \u2013 name of this node location ( List [ str ] ) \u2013 location in the blackboard, given as a list of strings. Should point to a dictionary. cb ( Callable ) \u2013 callback function with signature def cb(blackboard)->dict . The dictionary contents will be inserted in the given location","title":"__init__"},{"location":"concurrent/","text":"betfsm.betfsm.Concurrent Bases: GeneratorWithList Implements Concurrency, the children are executed at each tick concurrently until a child returns an outcome different from TICKING. stateDiagram-v2 direction TB classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state fork_state <<fork>> [*] --> fork_state fork_state --> state_1 fork_state --> state_2 state_1 --> OTHER : OTHER outcome state_2 --> OTHER : OTHER outcome state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state \"returns TICKING <br> when one are more TICK transitions <br> are received\" as TICKING state \"returns OTHER <br>when first outcome that arrives <br>\" as OTHER class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class TIMEOUT abortClass __init__ ( name , children = []) Implements Concurrency, the children are executed at each tick concurrently until a child returns an outcome different from TICKING. Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children. co_execute ( blackboard ) Python generator routine (co-routine). You can use yield <outcome> to return intermediate results Parameters: blackboard \u2013","title":"Concurrent"},{"location":"concurrent/#betfsm.betfsm.Concurrent","text":"Bases: GeneratorWithList Implements Concurrency, the children are executed at each tick concurrently until a child returns an outcome different from TICKING. stateDiagram-v2 direction TB classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state fork_state <<fork>> [*] --> fork_state fork_state --> state_1 fork_state --> state_2 state_1 --> OTHER : OTHER outcome state_2 --> OTHER : OTHER outcome state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state \"returns TICKING <br> when one are more TICK transitions <br> are received\" as TICKING state \"returns OTHER <br>when first outcome that arrives <br>\" as OTHER class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class TIMEOUT abortClass","title":"Concurrent"},{"location":"concurrent/#betfsm.betfsm.Concurrent.__init__","text":"Implements Concurrency, the children are executed at each tick concurrently until a child returns an outcome different from TICKING. Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"__init__"},{"location":"concurrent/#betfsm.betfsm.Concurrent.co_execute","text":"Python generator routine (co-routine). You can use yield <outcome> to return intermediate results Parameters: blackboard \u2013","title":"co_execute"},{"location":"concurrentfallback/","text":"betfsm.betfsm.ConcurrentFallback Bases: GeneratorWithList Implements a behaviortree-like Fallback node success is any other outcome, failure is CANCEL outcome There is a method add_state to add underlying nodes to ConcurrentFallback, these are executed in order. In contrast to Fallback this node runs concurrently. At each call, ConcurrentFallback runs through the list of underlying active states and: If an underlying state returns CANCEL, it becomes inactive. If all states have become inactive, the Sequence returns CANCEL (a \"success\") If an underlying active state returns another outcome besides TICKING and CANCEL, the Sequence returns the outcome of the first such state (a \"success\" ) and cancels the other running states. If any of the states has returned TICKING, the sequence returns TICKING In summary, it is similar to Fallback, but it calls all underlying states together (in order), and not one-by-one. ConcurrentFallback waits until all underlying states have finished ( a \"join\") stateDiagram-v2 direction TB classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state fork_state <<fork>> [*] --> fork_state fork_state --> state_1 fork_state --> state_2 state join_state <<fork>> state_1 --> join_state : CANCEL state_1 --> OTHER : OTHER outcome state_2 --> join_state : CANCEL state_2 --> OTHER : OTHER outcome join_state --> CANCEL state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state \"TICKING <br> if any TICK transition <br> is received\" as TICKING state \"OTHER <br>returns first other outome\" as OTHER state \"CANCEL <br>if both transitions <br> are received\" as CANCEL class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class CANCEL abortClass __init__ ( name , children = []) Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children. co_execute ( blackboard ) executes the underlying states in the fallback node, as much as possible concurrently. all outcomes except for CANCEL and TICKING indicate success. Fails with CANCEL when all underlying states have returned CANCEL. Parameters: blackboard \u2013","title":"ConcurrentFallback"},{"location":"concurrentfallback/#betfsm.betfsm.ConcurrentFallback","text":"Bases: GeneratorWithList Implements a behaviortree-like Fallback node success is any other outcome, failure is CANCEL outcome There is a method add_state to add underlying nodes to ConcurrentFallback, these are executed in order. In contrast to Fallback this node runs concurrently. At each call, ConcurrentFallback runs through the list of underlying active states and: If an underlying state returns CANCEL, it becomes inactive. If all states have become inactive, the Sequence returns CANCEL (a \"success\") If an underlying active state returns another outcome besides TICKING and CANCEL, the Sequence returns the outcome of the first such state (a \"success\" ) and cancels the other running states. If any of the states has returned TICKING, the sequence returns TICKING In summary, it is similar to Fallback, but it calls all underlying states together (in order), and not one-by-one. ConcurrentFallback waits until all underlying states have finished ( a \"join\") stateDiagram-v2 direction TB classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state fork_state <<fork>> [*] --> fork_state fork_state --> state_1 fork_state --> state_2 state join_state <<fork>> state_1 --> join_state : CANCEL state_1 --> OTHER : OTHER outcome state_2 --> join_state : CANCEL state_2 --> OTHER : OTHER outcome join_state --> CANCEL state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state \"TICKING <br> if any TICK transition <br> is received\" as TICKING state \"OTHER <br>returns first other outome\" as OTHER state \"CANCEL <br>if both transitions <br> are received\" as CANCEL class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class CANCEL abortClass","title":"ConcurrentFallback"},{"location":"concurrentfallback/#betfsm.betfsm.ConcurrentFallback.__init__","text":"Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"__init__"},{"location":"concurrentfallback/#betfsm.betfsm.ConcurrentFallback.co_execute","text":"executes the underlying states in the fallback node, as much as possible concurrently. all outcomes except for CANCEL and TICKING indicate success. Fails with CANCEL when all underlying states have returned CANCEL. Parameters: blackboard \u2013","title":"co_execute"},{"location":"concurrentsequence/","text":"betfsm.betfsm.ConcurrentSequence Bases: GeneratorWithList Implements a behaviortree-like Sequence node success is SUCCEED outcome, failure is any other outcome There is a method add_state to add underlying nodes to the Sequence, these are executed in order. In contrast to Sequence this node runs concurrently. At each call, ConcurrentSequence runs through the list of underlying active states and: If an underlying state returns SUCCEED, it becomes inactive. If all states have become inactive, the Sequence returns SUCCEED (a \"success\") If an underlying active state returns another outcome besides TICKING and SUCCEED, the Sequence returns the outcome of the first such state (a \"fail\" ) and cancels the other running states. If any of the states has returned TICKING, the sequence returns TICKING In summary, it is similar to Sequence, but it calls all underlying states together (in order), and not one-by-one. ConcurrentSequence waits until all underlying states have finished ( a \"join\") stateDiagram-v2 direction TB classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state fork_state <<fork>> [*] --> fork_state fork_state --> state_1 fork_state --> state_2 state join_state <<fork>> state_1 --> join_state : SUCCEED state_1 --> OTHER : OTHER outcome state_2 --> join_state : SUCCEED state_2 --> OTHER : OTHER outcome join_state --> SUCCEED state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state \"TICKING <br> if any TICK transition <br> is received\" as TICKING state \"OTHER <br>returns first other outome\" as OTHER state \"SUCCEED <br>if both transitions <br> are received\" as SUCCEED class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class TIMEOUT abortClass __init__ ( name , children = []) Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children. co_execute ( blackboard ) executes the underlying states in sequence, as much as possible concurrently. all outcomes except for SUCCEED and TICKING indicate failure. SUCCEEDs when all underlying states have returned SUCCEED. parameters: blackboard:","title":"ConcurrentSequence"},{"location":"concurrentsequence/#betfsm.betfsm.ConcurrentSequence","text":"Bases: GeneratorWithList Implements a behaviortree-like Sequence node success is SUCCEED outcome, failure is any other outcome There is a method add_state to add underlying nodes to the Sequence, these are executed in order. In contrast to Sequence this node runs concurrently. At each call, ConcurrentSequence runs through the list of underlying active states and: If an underlying state returns SUCCEED, it becomes inactive. If all states have become inactive, the Sequence returns SUCCEED (a \"success\") If an underlying active state returns another outcome besides TICKING and SUCCEED, the Sequence returns the outcome of the first such state (a \"fail\" ) and cancels the other running states. If any of the states has returned TICKING, the sequence returns TICKING In summary, it is similar to Sequence, but it calls all underlying states together (in order), and not one-by-one. ConcurrentSequence waits until all underlying states have finished ( a \"join\") stateDiagram-v2 direction TB classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state fork_state <<fork>> [*] --> fork_state fork_state --> state_1 fork_state --> state_2 state join_state <<fork>> state_1 --> join_state : SUCCEED state_1 --> OTHER : OTHER outcome state_2 --> join_state : SUCCEED state_2 --> OTHER : OTHER outcome join_state --> SUCCEED state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state \"TICKING <br> if any TICK transition <br> is received\" as TICKING state \"OTHER <br>returns first other outome\" as OTHER state \"SUCCEED <br>if both transitions <br> are received\" as SUCCEED class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class TIMEOUT abortClass","title":"ConcurrentSequence"},{"location":"concurrentsequence/#betfsm.betfsm.ConcurrentSequence.__init__","text":"Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"__init__"},{"location":"concurrentsequence/#betfsm.betfsm.ConcurrentSequence.co_execute","text":"executes the underlying states in sequence, as much as possible concurrently. all outcomes except for SUCCEED and TICKING indicate failure. SUCCEEDs when all underlying states have returned SUCCEED. parameters: blackboard:","title":"co_execute"},{"location":"default_callbacks/","text":"betfsm . betfsm . default_transitioncb ( statemachine , blackboard , source , outcome ) Callback for use in cbStateMachine Parameters: statemachine \u2013 statemachine in which this callback is called blackboard \u2013 the blackboard wich was used to execute this statemachine source \u2013 the source state of the transition outcome \u2013 the name of the transition Returns: \u2013 outcome or an override of the outcome betfsm . betfsm . default_statecb ( statemachine , blackboard , state ) Default callback used in TickingStateMachine. Parameters: statemachine \u2013 statemachine in which this callback is called blackboard \u2013 the blackboard wich was used to execute this statemachine state \u2013 state that will be entered","title":"Default callbacks"},{"location":"default_callbacks/#betfsm.betfsm.default_transitioncb","text":"Callback for use in cbStateMachine Parameters: statemachine \u2013 statemachine in which this callback is called blackboard \u2013 the blackboard wich was used to execute this statemachine source \u2013 the source state of the transition outcome \u2013 the name of the transition Returns: \u2013 outcome or an override of the outcome","title":"default_transitioncb"},{"location":"default_callbacks/#betfsm.betfsm.default_statecb","text":"Default callback used in TickingStateMachine. Parameters: statemachine \u2013 statemachine in which this callback is called blackboard \u2013 the blackboard wich was used to execute this statemachine state \u2013 state that will be entered","title":"default_statecb"},{"location":"etaslstatemachine/","text":"eTaSL Description of the interface towards eTaSL. Utility functions Some utility functions to manage tasks are provided: betfsm . betfsm_etasl . get_task ( blackboard , task_name ) get the default parameters for a task. Parameters: blackboard ( Blackboard ) \u2013 blackboard task_name ( str ) \u2013 name of the task betfsm . betfsm_etasl . load_task_list ( json_file_name , blackboard ) Loads a task list from a file. References to packages and environment variables in the name are expanded (using the expand_... functions) Parameters: json_file_name ( str ) \u2013 json file containing the task list. blackboard ( Blackboard ) \u2013 blackboard into which to load the task list. The eTaSLStateMachine betfsm.betfsm_etasl.eTaSL_StateMachine Bases: TickingStateMachine __init__ ( name , task_name , srv_name = '/etasl_node' , cb = default_parameter_setter , timeout = Duration ( seconds = 1.0 ), node = None , transitioncb = default_transitioncb , statecb = default_statecb ) Configurable statemachine to execute an eTaSL task that: uses TickingStateMachine to provide callbacks for transtions and state changes and support TICKING; uses a feedback to set parameters; puts the last message from the output topic in the blackboard under blackboard \"output\" . Parameters: name ( str ) \u2013 name of this state machine (i.e. task instance) task_name ( str ) \u2013 name of the task to be executed (i.e. task type) Will be looked up in the blackboard. srv_name ( str , default: '/etasl_node' ) \u2013 name of the eTaSL node, by default /etasl_node output_topic \u2013 name of the topic where to find the output of eTaSL. A topic with interface etasl_interfaces/msg/Output is expected. cb ( Callable , default: default_parameter_setter ) \u2013 callback that sets the parameters, with signature def cb(blackboard) ->param where param is a Dict with the parameters of the task that will be used to update the default parameters. timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 [optional] returns TIMEOUT if the communication timeout of any of the substeps is exceeded. Uses a duration of 1 second otherwise. node ( Node , default: None ) \u2013 [optional] ROS2 node to be used. Uses BeTFSMNode.get_instance() otherwise. transitioncb ( Callable , default: default_transitioncb ) \u2013 [optional] callback that is called at each transition, signature def transitioncb(statemachine,blackboard,source,outcome)->outcome statecb ( Callable , default: default_statecb ) \u2013 [optional] callback that is called at each, signature default_statecb(statemachine,blackboard,state) warning TODO: name of output topic needs to be changed. Auxiliary states (used to define eTaSLStateMachine) betfsm.betfsm_etasl.SetTaskParameters Bases: ServiceClient __init__ ( name , task_name , srv_name = '/etasl_node' , cb = default_parameter_setter , timeout = Duration ( seconds = 1.0 ), node = None ) calls a service to instruct eTaSL to read a robot specification file. The file is obtained from the task Parameters: name ( str ) \u2013 instance name task_name ( str ) \u2013 name that will be used to find back the task with specifies the robot specification file. srv_name ( str , default: '/etasl_node' ) \u2013 name of the etasl node, by default /etasl_node cb ( Callable , default: default_parameter_setter ) \u2013 callback that sets the parameters, with signature def param_setters(blackboard) ->param where param is a Dict with the parameters of the task. timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 returns TIMEOUT if timeout is exceeded. node ( Node , default: None ) \u2013 ROS2 node, by default BeTFSMNode.get_instance() betfsm.betfsm_etasl.ReadRobotSpecification Bases: ServiceClient __init__ ( name , task_name , srv_name = '/etasl_node' , timeout = Duration ( seconds = 1.0 ), node = None ) calls a service to instruct eTaSL to read a robot specification file. The file is obtained from the task Parameters: name ( str ) \u2013 instance name task_name ( str ) \u2013 name that will be used to find back the task with specifies the robot specification file. srv_name ( str , default: '/etasl_node' ) \u2013 name of the etasl node, by default /etasl_node timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 returns TIMEOUT if timeout is exceeded. node ( Node , default: None ) \u2013 ROS2 node, by default BeTFSMNode.get_instance() betfsm.betfsm_etasl.ReadTaskSpecification Bases: ServiceClient __init__ ( name , task_name , srv_name = '/etasl_node' , timeout = Duration ( seconds = 1.0 ), node = None ) calls a service to instruct eTaSL to read a task specification file. The file is obtained from the task Parameters: task_name ( str ) \u2013 name that will be used to find back the task with specifies the task specification file. srv_name ( str , default: '/etasl_node' ) \u2013 name of the etasl node, by default /etasl_node timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 returns TIMEOUT if timeout is exceeded. node ( Node , default: None ) \u2013 ROS2 node, by default BeTFSMNode.get_instance() betfsm.betfsm_etasl.eTaSLOutput Bases: TickingState __init__ ( name , topic , qos = 30 , bb_location = [ 'output' ], node = None ) At every tick processes the latest message from the topic and puts it on a predetermined location in the blackboard. Parameters: name ( str ) \u2013 instance name topic ( str ) \u2013 topic to listen to, topics with interfacev etasl_interfaces/msg/Output are expected qos ( QoSProfile , default: 30 ) \u2013 specification of the topic quality of service profile (QOSProfile) bb_location ( List , default: ['output'] ) \u2013 list of strings indicating location in the blackboard. node ( Node , default: None ) \u2013 ROS2 node where the subscription will run. if None, BeTFSMNode.get_instance() is used. warning will only store messages where for all variables in the message is_declared is true. betfsm.betfsm_etasl.eTaSLEvent Bases: TickingState At every tick processes the latest message from the topic. Node will CANCEL when it is ticked and no topic has been received. __init__ ( name , topic , qos = 10 , mapping = { 'e_finished@etasl_node' : ( 1 , SUCCEED )}, node = None ) A node that waits until an event is received. Parameters: name ( str ) \u2013 instance name topic ( str ) \u2013 name of the topic. Topics of type String are expected. qos ( QoSProfile , default: 10 ) \u2013 To be able to adapt the QoS mapping ( Dict [ str , tuple [ int , str ]] , default: {'e_finished@etasl_node': (1, SUCCEED )} ) \u2013 maps the event string to a priority and outcome. When multiple messages are received, the event with lowest priority will be used. For events with the same priority the earliest event will be selected. node ( Node , default: None ) \u2013 node or BeTFSMNode if node==None.","title":"BeTFSM eTaSL"},{"location":"etaslstatemachine/#etasl","text":"Description of the interface towards eTaSL.","title":"eTaSL"},{"location":"etaslstatemachine/#utility-functions","text":"Some utility functions to manage tasks are provided:","title":"Utility functions"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.get_task","text":"get the default parameters for a task. Parameters: blackboard ( Blackboard ) \u2013 blackboard task_name ( str ) \u2013 name of the task","title":"get_task"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.load_task_list","text":"Loads a task list from a file. References to packages and environment variables in the name are expanded (using the expand_... functions) Parameters: json_file_name ( str ) \u2013 json file containing the task list. blackboard ( Blackboard ) \u2013 blackboard into which to load the task list.","title":"load_task_list"},{"location":"etaslstatemachine/#the-etaslstatemachine","text":"","title":"The eTaSLStateMachine"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.eTaSL_StateMachine","text":"Bases: TickingStateMachine","title":"eTaSL_StateMachine"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.eTaSL_StateMachine.__init__","text":"Configurable statemachine to execute an eTaSL task that: uses TickingStateMachine to provide callbacks for transtions and state changes and support TICKING; uses a feedback to set parameters; puts the last message from the output topic in the blackboard under blackboard \"output\" . Parameters: name ( str ) \u2013 name of this state machine (i.e. task instance) task_name ( str ) \u2013 name of the task to be executed (i.e. task type) Will be looked up in the blackboard. srv_name ( str , default: '/etasl_node' ) \u2013 name of the eTaSL node, by default /etasl_node output_topic \u2013 name of the topic where to find the output of eTaSL. A topic with interface etasl_interfaces/msg/Output is expected. cb ( Callable , default: default_parameter_setter ) \u2013 callback that sets the parameters, with signature def cb(blackboard) ->param where param is a Dict with the parameters of the task that will be used to update the default parameters. timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 [optional] returns TIMEOUT if the communication timeout of any of the substeps is exceeded. Uses a duration of 1 second otherwise. node ( Node , default: None ) \u2013 [optional] ROS2 node to be used. Uses BeTFSMNode.get_instance() otherwise. transitioncb ( Callable , default: default_transitioncb ) \u2013 [optional] callback that is called at each transition, signature def transitioncb(statemachine,blackboard,source,outcome)->outcome statecb ( Callable , default: default_statecb ) \u2013 [optional] callback that is called at each, signature default_statecb(statemachine,blackboard,state) warning TODO: name of output topic needs to be changed.","title":"__init__"},{"location":"etaslstatemachine/#auxiliary-states-used-to-define-etaslstatemachine","text":"","title":"Auxiliary states (used to define eTaSLStateMachine)"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.SetTaskParameters","text":"Bases: ServiceClient","title":"SetTaskParameters"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.SetTaskParameters.__init__","text":"calls a service to instruct eTaSL to read a robot specification file. The file is obtained from the task Parameters: name ( str ) \u2013 instance name task_name ( str ) \u2013 name that will be used to find back the task with specifies the robot specification file. srv_name ( str , default: '/etasl_node' ) \u2013 name of the etasl node, by default /etasl_node cb ( Callable , default: default_parameter_setter ) \u2013 callback that sets the parameters, with signature def param_setters(blackboard) ->param where param is a Dict with the parameters of the task. timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 returns TIMEOUT if timeout is exceeded. node ( Node , default: None ) \u2013 ROS2 node, by default BeTFSMNode.get_instance()","title":"__init__"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.ReadRobotSpecification","text":"Bases: ServiceClient","title":"ReadRobotSpecification"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.ReadRobotSpecification.__init__","text":"calls a service to instruct eTaSL to read a robot specification file. The file is obtained from the task Parameters: name ( str ) \u2013 instance name task_name ( str ) \u2013 name that will be used to find back the task with specifies the robot specification file. srv_name ( str , default: '/etasl_node' ) \u2013 name of the etasl node, by default /etasl_node timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 returns TIMEOUT if timeout is exceeded. node ( Node , default: None ) \u2013 ROS2 node, by default BeTFSMNode.get_instance()","title":"__init__"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.ReadTaskSpecification","text":"Bases: ServiceClient","title":"ReadTaskSpecification"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.ReadTaskSpecification.__init__","text":"calls a service to instruct eTaSL to read a task specification file. The file is obtained from the task Parameters: task_name ( str ) \u2013 name that will be used to find back the task with specifies the task specification file. srv_name ( str , default: '/etasl_node' ) \u2013 name of the etasl node, by default /etasl_node timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 returns TIMEOUT if timeout is exceeded. node ( Node , default: None ) \u2013 ROS2 node, by default BeTFSMNode.get_instance()","title":"__init__"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.eTaSLOutput","text":"Bases: TickingState","title":"eTaSLOutput"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.eTaSLOutput.__init__","text":"At every tick processes the latest message from the topic and puts it on a predetermined location in the blackboard. Parameters: name ( str ) \u2013 instance name topic ( str ) \u2013 topic to listen to, topics with interfacev etasl_interfaces/msg/Output are expected qos ( QoSProfile , default: 30 ) \u2013 specification of the topic quality of service profile (QOSProfile) bb_location ( List , default: ['output'] ) \u2013 list of strings indicating location in the blackboard. node ( Node , default: None ) \u2013 ROS2 node where the subscription will run. if None, BeTFSMNode.get_instance() is used. warning will only store messages where for all variables in the message is_declared is true.","title":"__init__"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.eTaSLEvent","text":"Bases: TickingState At every tick processes the latest message from the topic. Node will CANCEL when it is ticked and no topic has been received.","title":"eTaSLEvent"},{"location":"etaslstatemachine/#betfsm.betfsm_etasl.eTaSLEvent.__init__","text":"A node that waits until an event is received. Parameters: name ( str ) \u2013 instance name topic ( str ) \u2013 name of the topic. Topics of type String are expected. qos ( QoSProfile , default: 10 ) \u2013 To be able to adapt the QoS mapping ( Dict [ str , tuple [ int , str ]] , default: {'e_finished@etasl_node': (1, SUCCEED )} ) \u2013 maps the event string to a priority and outcome. When multiple messages are received, the event with lowest priority will be used. For events with the same priority the earliest event will be selected. node ( Node , default: None ) \u2013 node or BeTFSMNode if node==None.","title":"__init__"},{"location":"fallback/","text":"betfsm.betfsm.Fallback Bases: GeneratorWithList Implements a behaviortree-like Fallback node success any other outcome, failure is CANCEL outcome There is a method add_state to add underlying nodes to the Fallback node, these are executed in order. If any node succeeds, this outcome is directly returned; if a node returns TICKING, the fallback node returns TICKING; and if the node returns CANCEL, the execution of the next node in the list is started (without any intermediate tick!). stateDiagram-v2 classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> Loop Loop --> state_1 : current_state==1 Loop --> state_2 : current_state==2 Loop --> CANCEL : last state succeeded state_1 --> Loop : CANCEL state_2 --> Loop : CANCEL state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state_1 --> OTHER : OTHER outcome state_2 --> OTHER : OTHER outcome class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class CANCEL abortClass __init__ ( name , children = []) Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"Fallback"},{"location":"fallback/#betfsm.betfsm.Fallback","text":"Bases: GeneratorWithList Implements a behaviortree-like Fallback node success any other outcome, failure is CANCEL outcome There is a method add_state to add underlying nodes to the Fallback node, these are executed in order. If any node succeeds, this outcome is directly returned; if a node returns TICKING, the fallback node returns TICKING; and if the node returns CANCEL, the execution of the next node in the list is started (without any intermediate tick!). stateDiagram-v2 classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> Loop Loop --> state_1 : current_state==1 Loop --> state_2 : current_state==2 Loop --> CANCEL : last state succeeded state_1 --> Loop : CANCEL state_2 --> Loop : CANCEL state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state_1 --> OTHER : OTHER outcome state_2 --> OTHER : OTHER outcome class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class CANCEL abortClass","title":"Fallback"},{"location":"fallback/#betfsm.betfsm.Fallback.__init__","text":"Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"__init__"},{"location":"generator/","text":"betfsm.betfsm.Generator Bases: TickingState Uses a python generator to define a TickingState. It implements methods entry , doo , and exit of TickingState using the given callback function (which is a python generator that can return intermediate results usig yield ). This makes it easy to specify a TickingState. Subclasses need to implement/override the abstract method co_execute(self, blackboard:Blackboard) __init__ ( name , outcomes ) Parameters: name ( str ) \u2013 name of the node outcomes ( List [ str ] ) \u2013 a list of strings indicating the expected outcomes, TICKING and ABORT will be automatically added. betfsm.betfsm.GeneratorWithState Bases: Generator A Generator with one underlying states __init__ ( name , outcomes , state ) Parameters: name ( str ) \u2013 name of the node outcomes ( List [ str ] ) \u2013 a list of strings indicating the expected outcomes, the outcomes of the underlying state are automatically added. state ( TickingState ) \u2013 underlying state betfsm.betfsm.GeneratorWithList Bases: Generator A generator with some facilities to maintain an ordered list of children __init__ ( name , outcomes , children = []) Parameters: name ( str ) \u2013 name outcomes ( List [ str ] ) \u2013 list of possible outcomes (in addition to the outcomes of the underlying states) children ( List [ TickingState ] , default: [] ) \u2013 a list of states. you can use add_state(...) to add children. add_state ( state ) adds a state to the sequence parameters: state: state intance returns: self (to allow method chaining) reset () resets the sequence and ensures tht the underlying states are also reset.","title":"Generator"},{"location":"generator/#betfsm.betfsm.Generator","text":"Bases: TickingState Uses a python generator to define a TickingState. It implements methods entry , doo , and exit of TickingState using the given callback function (which is a python generator that can return intermediate results usig yield ). This makes it easy to specify a TickingState. Subclasses need to implement/override the abstract method co_execute(self, blackboard:Blackboard)","title":"Generator"},{"location":"generator/#betfsm.betfsm.Generator.__init__","text":"Parameters: name ( str ) \u2013 name of the node outcomes ( List [ str ] ) \u2013 a list of strings indicating the expected outcomes, TICKING and ABORT will be automatically added.","title":"__init__"},{"location":"generator/#betfsm.betfsm.GeneratorWithState","text":"Bases: Generator A Generator with one underlying states","title":"GeneratorWithState"},{"location":"generator/#betfsm.betfsm.GeneratorWithState.__init__","text":"Parameters: name ( str ) \u2013 name of the node outcomes ( List [ str ] ) \u2013 a list of strings indicating the expected outcomes, the outcomes of the underlying state are automatically added. state ( TickingState ) \u2013 underlying state","title":"__init__"},{"location":"generator/#betfsm.betfsm.GeneratorWithList","text":"Bases: Generator A generator with some facilities to maintain an ordered list of children","title":"GeneratorWithList"},{"location":"generator/#betfsm.betfsm.GeneratorWithList.__init__","text":"Parameters: name ( str ) \u2013 name outcomes ( List [ str ] ) \u2013 list of possible outcomes (in addition to the outcomes of the underlying states) children ( List [ TickingState ] , default: [] ) \u2013 a list of states. you can use add_state(...) to add children.","title":"__init__"},{"location":"generator/#betfsm.betfsm.GeneratorWithList.add_state","text":"adds a state to the sequence parameters: state: state intance returns: self (to allow method chaining)","title":"add_state"},{"location":"generator/#betfsm.betfsm.GeneratorWithList.reset","text":"resets the sequence and ensures tht the underlying states are also reset.","title":"reset"},{"location":"lifecycle/","text":"betfsm.betfsm_ros.LifeCycle Bases: ServiceClient ROS2 lifecycle (simplified): stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> unconfigured unconfigured --> inactive : CONFIGURE inactive --> active : ACTIVATE inactive --> unconfigured : CLEANUP inactive --> finalized : INACTIVE_SHUTDOWN active --> inactive : DEACTIVATE active --> finalized : ACTIVE_SHUTDOWN unconfigured --> finalized : UNCONFIGURED_SHUTDOWN class Transition(Enum): CONFIGURE = 1 CLEANUP = 2 ACTIVATE = 3 DEACTIVATE = 4 UNCONFIGURED_SHUTDOWN = 5 INACTIVE_SHUTDOWN = 6 ACTIVE_SHUTDOWN = 7 A ROS 2 node can take a while before reaching the desired state. These transitional states are not depicted here. Documentation of the full state machine can be found here __init__ ( name , srv_name = '/etasl_node' , transition = Transition . ACTIVATE , timeout = Duration ( seconds = 1.0 ), node = None ) Parameters: name ( str ) \u2013 instance name of the lifecycle action srv_name ( str , default: '/etasl_node' ) \u2013 name of the node whose lifecycle to control transition ( Transition , default: ACTIVATE ) \u2013 indicates which transition timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 duration that indicates the timeout, 0 is forever node ( Node , default: None ) \u2013 if None, singleton BeTFSMNode.get_instance() will be used.","title":"LifeCycle"},{"location":"lifecycle/#betfsm.betfsm_ros.LifeCycle","text":"Bases: ServiceClient ROS2 lifecycle (simplified): stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> unconfigured unconfigured --> inactive : CONFIGURE inactive --> active : ACTIVATE inactive --> unconfigured : CLEANUP inactive --> finalized : INACTIVE_SHUTDOWN active --> inactive : DEACTIVATE active --> finalized : ACTIVE_SHUTDOWN unconfigured --> finalized : UNCONFIGURED_SHUTDOWN class Transition(Enum): CONFIGURE = 1 CLEANUP = 2 ACTIVATE = 3 DEACTIVATE = 4 UNCONFIGURED_SHUTDOWN = 5 INACTIVE_SHUTDOWN = 6 ACTIVE_SHUTDOWN = 7 A ROS 2 node can take a while before reaching the desired state. These transitional states are not depicted here. Documentation of the full state machine can be found here","title":"LifeCycle"},{"location":"lifecycle/#betfsm.betfsm_ros.LifeCycle.__init__","text":"Parameters: name ( str ) \u2013 instance name of the lifecycle action srv_name ( str , default: '/etasl_node' ) \u2013 name of the node whose lifecycle to control transition ( Transition , default: ACTIVATE ) \u2013 indicates which transition timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 duration that indicates the timeout, 0 is forever node ( Node , default: None ) \u2013 if None, singleton BeTFSMNode.get_instance() will be used.","title":"__init__"},{"location":"logblackboard/","text":"betfsm.betfsm.LogBlackboard Bases: Generator Logs blackboard or part of blackboard __init__ ( name , location = []) Prints (a part of) the blackboard to the log. Info-level is used. Parameters: name ( str ) \u2013 instance name location ( List [ str ] , default: [] ) \u2013 a list of strings that describes a location in the blackboard.","title":"LogBlackboard"},{"location":"logblackboard/#betfsm.betfsm.LogBlackboard","text":"Bases: Generator Logs blackboard or part of blackboard","title":"LogBlackboard"},{"location":"logblackboard/#betfsm.betfsm.LogBlackboard.__init__","text":"Prints (a part of) the blackboard to the log. Info-level is used. Parameters: name ( str ) \u2013 instance name location ( List [ str ] , default: [] ) \u2013 a list of strings that describes a location in the blackboard.","title":"__init__"},{"location":"message/","text":"betfsm.betfsm.Message Bases: Generator Message(msg) returns a State that displays a message __init__ ( name = 'message' , * , msg = None , cb = None ) Displays a message to the log. Parameters: name ( str , default: 'message' ) \u2013 instance name, default message msg ( str , default: None ) \u2013 string describing the message cb ( Callable , default: None ) \u2013 callback returning the message. Signature def cb(blackboard)->str . The callback allows the user to compute the message at time of evaluation, e.g. to report on values on the blackboard. warning Only one of the arguments msg or cb can be specified example Message(lambda bb: f'{bb[\"some_key_in_blackboard\"]=}' )","title":"Message"},{"location":"message/#betfsm.betfsm.Message","text":"Bases: Generator Message(msg) returns a State that displays a message","title":"Message"},{"location":"message/#betfsm.betfsm.Message.__init__","text":"Displays a message to the log. Parameters: name ( str , default: 'message' ) \u2013 instance name, default message msg ( str , default: None ) \u2013 string describing the message cb ( Callable , default: None ) \u2013 callback returning the message. Signature def cb(blackboard)->str . The callback allows the user to compute the message at time of evaluation, e.g. to report on values on the blackboard. warning Only one of the arguments msg or cb can be specified example Message(lambda bb: f'{bb[\"some_key_in_blackboard\"]=}' )","title":"__init__"},{"location":"repeat/","text":"betfsm.betfsm.Repeat Bases: GeneratorWithState Repeats underlying state for maxcount times or until an outcome other than SUCCEED is reached. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white state Repeat { [*] --> my_state state \"State\" as my_state my_state --> my_state : succeed } [*] --> Repeat my_state --> SUCCEED : #succeed > maxcount my_state --> OTHER : other outcome my_state --> TICKING : ticking class SUCCEED successClass class OTHER otherClass class TICKING tickingClass Note: There is no tick between the repetitions. If you have an underlying state that directly returns SUCCEED, the sequence will be executed without ticks. __init__ ( name , maxcount , state ) Repeats underlying state for maxcount times or until an outcome other than SUCCEED is reached Parameters: name ( str ) \u2013 name of the instance maxcount ( int ) \u2013 Maximum number of times that underlying state will be executed. -1 indicates that you want to loop forever. state ( TickingState ) \u2013 underlying state","title":"Repeat"},{"location":"repeat/#betfsm.betfsm.Repeat","text":"Bases: GeneratorWithState Repeats underlying state for maxcount times or until an outcome other than SUCCEED is reached. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white state Repeat { [*] --> my_state state \"State\" as my_state my_state --> my_state : succeed } [*] --> Repeat my_state --> SUCCEED : #succeed > maxcount my_state --> OTHER : other outcome my_state --> TICKING : ticking class SUCCEED successClass class OTHER otherClass class TICKING tickingClass Note: There is no tick between the repetitions. If you have an underlying state that directly returns SUCCEED, the sequence will be executed without ticks.","title":"Repeat"},{"location":"repeat/#betfsm.betfsm.Repeat.__init__","text":"Repeats underlying state for maxcount times or until an outcome other than SUCCEED is reached Parameters: name ( str ) \u2013 name of the instance maxcount ( int ) \u2013 Maximum number of times that underlying state will be executed. -1 indicates that you want to loop forever. state ( TickingState ) \u2013 underlying state","title":"__init__"},{"location":"sequence/","text":"betfsm.betfsm.Sequence Bases: GeneratorWithList Implements a behaviortree-like Sequence node success is SUCCEED outcome, failure is any other outcome There is a method add_state to add underlying nodes to the Sequence, these are executed in order. If any node fails, this outcome is directly returned; if a node returns TICKING, the sequence returns TICKING; and if the node returns SUCCEED, the execution of the next node in the list is started (without any intermediate tick!). stateDiagram-v2 classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> Loop Loop --> state_1 : current_state==1 Loop --> state_2 : current_state==2 Loop --> SUCCEED : last state succeeded state_1 --> Loop : SUCCEED state_2 --> Loop : SUCCEED state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state_1 --> OTHER : OTHER outcome state_2 --> OTHER : OTHER outcome class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class TIMEOUT abortClass __init__ ( name , children = []) Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"Sequence"},{"location":"sequence/#betfsm.betfsm.Sequence","text":"Bases: GeneratorWithList Implements a behaviortree-like Sequence node success is SUCCEED outcome, failure is any other outcome There is a method add_state to add underlying nodes to the Sequence, these are executed in order. If any node fails, this outcome is directly returned; if a node returns TICKING, the sequence returns TICKING; and if the node returns SUCCEED, the execution of the next node in the list is started (without any intermediate tick!). stateDiagram-v2 classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white [*] --> Loop Loop --> state_1 : current_state==1 Loop --> state_2 : current_state==2 Loop --> SUCCEED : last state succeeded state_1 --> Loop : SUCCEED state_2 --> Loop : SUCCEED state_1 --> TICKING : TICKING state_2 --> TICKING : TICKING state_1 --> OTHER : OTHER outcome state_2 --> OTHER : OTHER outcome class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class TIMEOUT abortClass","title":"Sequence"},{"location":"sequence/#betfsm.betfsm.Sequence.__init__","text":"Parameters: name ( str ) \u2013 name of the sequence children ( List [ TickingState ] , default: [] ) \u2013 a list of states you can use add_state(...) to add children.","title":"__init__"},{"location":"serviceclient/","text":"betfsm.betfsm_ros.ServiceClient Bases: Generator Creates a TickingState that calls a ROS2 service and generates an outcome when the service returns back. While waiting, it continues to tick. The methods fill_in_request and process_results should be overriden. Outcome is whatever process_result returns (should be listed in outcomes argument to constructor) stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state ServiceClient { direction TB [*] --> waiting state \"Waiting for service\" as waiting state \"fill_in_request() <br> calling service\" as calling state \"Waiting for result<br>process_results()\" as result waiting --> calling : ready calling --> result : request send } [*] --> ServiceClient waiting --> TIMEOUT : time exceeded waiting --> TICKING result --> TICKING : ticking result --> TIMEOUT : time exceeded result --> OUTCOME : result processed class SUCCEED successClass+ class OUTCOME otherClass class TICKING tickingClass class TIMEOUT abortClass __init__ ( name , srv_name , srv_type , outcomes , timeout = Duration ( seconds = 1.0 ), node = None ) Creates a TickingState that calls a service and generates an outcome when the service returns back. While waiting, it continues to tick. Parameters: name ( str ) \u2013 name of the state srv_name ( str ) \u2013 name of the service srv_type ( Type ) \u2013 type of the service outcomes ( List [ str ] ) \u2013 outcomes to be expected (TIMEOUT and TICKING will be added) timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 maximum time for contacting service and processing and retrieving request. (special value: Duration(): ad infinitum) node ( Node , default: None ) \u2013 node, if None, BeTFSMNode.get_instance() will be used. fill_in_request ( blackboard , request ) fills in the self.req object (of the type srv_type.Request) with the appropriate parameters of the service call Parameters: blackboard ( Blackboard ) \u2013 blackboard to be used request ( srv_type.Request) ) \u2013 request to be filled in Returns: request ( Request ) \u2013 request that was filled in process_result ( blackboard , result ) gets the result and puts it in the blackboard (if needed) and returns an outcome Parameters: blackboard ( Blackboard ) \u2013 blackboard to be used result(srv_type.Result) \u2013 result returned by the service Returns: outcome ( str ) \u2013 str the outcome to give back (should be final outcome, i.e. TICKING not allowed)","title":"ServiceClient"},{"location":"serviceclient/#betfsm.betfsm_ros.ServiceClient","text":"Bases: Generator Creates a TickingState that calls a ROS2 service and generates an outcome when the service returns back. While waiting, it continues to tick. The methods fill_in_request and process_results should be overriden. Outcome is whatever process_result returns (should be listed in outcomes argument to constructor) stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state ServiceClient { direction TB [*] --> waiting state \"Waiting for service\" as waiting state \"fill_in_request() <br> calling service\" as calling state \"Waiting for result<br>process_results()\" as result waiting --> calling : ready calling --> result : request send } [*] --> ServiceClient waiting --> TIMEOUT : time exceeded waiting --> TICKING result --> TICKING : ticking result --> TIMEOUT : time exceeded result --> OUTCOME : result processed class SUCCEED successClass+ class OUTCOME otherClass class TICKING tickingClass class TIMEOUT abortClass","title":"ServiceClient"},{"location":"serviceclient/#betfsm.betfsm_ros.ServiceClient.__init__","text":"Creates a TickingState that calls a service and generates an outcome when the service returns back. While waiting, it continues to tick. Parameters: name ( str ) \u2013 name of the state srv_name ( str ) \u2013 name of the service srv_type ( Type ) \u2013 type of the service outcomes ( List [ str ] ) \u2013 outcomes to be expected (TIMEOUT and TICKING will be added) timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 maximum time for contacting service and processing and retrieving request. (special value: Duration(): ad infinitum) node ( Node , default: None ) \u2013 node, if None, BeTFSMNode.get_instance() will be used.","title":"__init__"},{"location":"serviceclient/#betfsm.betfsm_ros.ServiceClient.fill_in_request","text":"fills in the self.req object (of the type srv_type.Request) with the appropriate parameters of the service call Parameters: blackboard ( Blackboard ) \u2013 blackboard to be used request ( srv_type.Request) ) \u2013 request to be filled in Returns: request ( Request ) \u2013 request that was filled in","title":"fill_in_request"},{"location":"serviceclient/#betfsm.betfsm_ros.ServiceClient.process_result","text":"gets the result and puts it in the blackboard (if needed) and returns an outcome Parameters: blackboard ( Blackboard ) \u2013 blackboard to be used result(srv_type.Result) \u2013 result returned by the service Returns: outcome ( str ) \u2013 str the outcome to give back (should be final outcome, i.e. TICKING not allowed)","title":"process_result"},{"location":"tickingstate/","text":"betfsm.betfsm.TickingState Implements a 'ticking' state, i.e. a state that takes a longer time, but cooperatively yields the initiative back to the caller (cooperative concurrency): stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white classDef centerClass text-align:center entry --> doo : returns <br>CONTINUE or TICK doo --> exit : returns not TICK doo --> doo: returns<br>TICK entry -->exit: returns <br>not TICK or CONTINUE exit --> entry : exit() finished <br> or reset() called doo --> exit : reset() called entry: calls entry()<br>if TICK return TICK<br>if exception return ABORT doo: calls doo()<br> if TICK return TICK <br>if exception return ABORT exit: calls exit()<br> return outcome<br>if exception return ABORT class entry centerClass note You can choose whether to tick between entry() and doo() by letting entry() return CONTINUE note exit() is always called when execute is called for the last time, even when there are exceptions. note expects the following methods to be overridden by subclases: entry() doo() exit() reset() (but call super().reset() ) warning use is similar to State , but if it returns TICKING, it is expected to be called again, if not, the user needs to call reset() before using the state again. __init__ ( name , outcomes ) Parameters: name ( str ) \u2013 name of the TickingState. This is meant to be an instance-name, not a class-name. outcomes ( List [ str ] ) \u2013 all possible outcomes of the state, TICKING and ABORT will be added. accept ( visitor ) calls the visitor with itself and possibly iterates over its children. See also Visitor doo ( blackboard ) is repeatedly called after the first time execute() is called. Parameters: blackboard ( Blackboard ) \u2013 Returns: str \u2013 A string with value: TICKING (execute will return and next time will call doo() ); str \u2013 OTHER string (execute will call immediately exit(), i.e. without a tick ) Note if this throws an exception, outcome=ABORT and and exit() is called immediately If one likes more detailed behavior, doo needs to catch the exception itself. entry ( blackboard ) called the first time execute() is called. Parameters: blackboard ( Blackboard ) \u2013 Returns: str \u2013 A string with value: CONTINUE (execute will call directly doo() ); TICKING (execute will return and next time will call doo() ); OTHER string ( exit() will be immediately called, without a tick) Note can raise exception, equivalent to returning ABORT. In that case exit() is called. If one likes more detailed behavior, entry needs to catch the exception itself. exit () method that is always called when execute is called the last time Returns: str \u2013 A string the outcome (next time execute will call entry() ) Note method has no blackboard parameter, since it could be called from reset() which does not and should not know the blackboard parameter. Warning can't raise an exception! reset () External reset of the TickingState to its initial condition. exit() is called when appropriate","title":"TickingState"},{"location":"tickingstate/#betfsm.betfsm.TickingState","text":"Implements a 'ticking' state, i.e. a state that takes a longer time, but cooperatively yields the initiative back to the caller (cooperative concurrency): stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white classDef centerClass text-align:center entry --> doo : returns <br>CONTINUE or TICK doo --> exit : returns not TICK doo --> doo: returns<br>TICK entry -->exit: returns <br>not TICK or CONTINUE exit --> entry : exit() finished <br> or reset() called doo --> exit : reset() called entry: calls entry()<br>if TICK return TICK<br>if exception return ABORT doo: calls doo()<br> if TICK return TICK <br>if exception return ABORT exit: calls exit()<br> return outcome<br>if exception return ABORT class entry centerClass note You can choose whether to tick between entry() and doo() by letting entry() return CONTINUE note exit() is always called when execute is called for the last time, even when there are exceptions. note expects the following methods to be overridden by subclases: entry() doo() exit() reset() (but call super().reset() ) warning use is similar to State , but if it returns TICKING, it is expected to be called again, if not, the user needs to call reset() before using the state again.","title":"TickingState"},{"location":"tickingstate/#betfsm.betfsm.TickingState.__init__","text":"Parameters: name ( str ) \u2013 name of the TickingState. This is meant to be an instance-name, not a class-name. outcomes ( List [ str ] ) \u2013 all possible outcomes of the state, TICKING and ABORT will be added.","title":"__init__"},{"location":"tickingstate/#betfsm.betfsm.TickingState.accept","text":"calls the visitor with itself and possibly iterates over its children. See also Visitor","title":"accept"},{"location":"tickingstate/#betfsm.betfsm.TickingState.doo","text":"is repeatedly called after the first time execute() is called. Parameters: blackboard ( Blackboard ) \u2013 Returns: str \u2013 A string with value: TICKING (execute will return and next time will call doo() ); str \u2013 OTHER string (execute will call immediately exit(), i.e. without a tick ) Note if this throws an exception, outcome=ABORT and and exit() is called immediately If one likes more detailed behavior, doo needs to catch the exception itself.","title":"doo"},{"location":"tickingstate/#betfsm.betfsm.TickingState.entry","text":"called the first time execute() is called. Parameters: blackboard ( Blackboard ) \u2013 Returns: str \u2013 A string with value: CONTINUE (execute will call directly doo() ); TICKING (execute will return and next time will call doo() ); OTHER string ( exit() will be immediately called, without a tick) Note can raise exception, equivalent to returning ABORT. In that case exit() is called. If one likes more detailed behavior, entry needs to catch the exception itself.","title":"entry"},{"location":"tickingstate/#betfsm.betfsm.TickingState.exit","text":"method that is always called when execute is called the last time Returns: str \u2013 A string the outcome (next time execute will call entry() ) Note method has no blackboard parameter, since it could be called from reset() which does not and should not know the blackboard parameter. Warning can't raise an exception!","title":"exit"},{"location":"tickingstate/#betfsm.betfsm.TickingState.reset","text":"External reset of the TickingState to its initial condition. exit() is called when appropriate","title":"reset"},{"location":"tickingstatemachine/","text":"betfsm.betfsm.TickingStateMachine Bases: TickingState A StateMachine that calls a callback function before entering a state and/or at each transition. This statemachine is capable of working together with TickingState: will exit when TICKING outcome is given by one of the substates, but then if it is called again, it will have remembered the state that had the TICKING outcome and start from that state. if returning with any other outcome, will start next time from the start state. should be drop in replacement of Yasmin StateMachine, (but not the other way around, StateMachine can't handle TickingStates __init__ ( name , outcomes , transitioncb = default_transitioncb , statecb = default_statecb ) TickintStatemachine is a statemachine that can maintain TickingStates. Parameters: name ( str ) \u2013 (instance) name of the state machine outcomes ( List [ str ] ) \u2013 the allowed outcomes of the state machine, any outcome not specified in transitions will be an outcome of the state machine and should be contained in outcomes (otherwise exception+abort) transitioncb \u2013 callback function called at each transition. Signature transitioncb(source_state:str, transtion:str, target_state:str). See also statecb \u2013 callback function called before entering each state. Signature statecb(name) accept ( visitor ) accepts a visitor to go through all states of an hierarchy add_state ( state , transitions = None ) add_state(state,transitions) adds a state and associates transitions in this state-machine with this state. Parameters: state ( TickingState ) \u2013 state to be added, it will be added under its name (i.e. state.name, as defined in TickingState) transitions ( Dict [ str , str ] , default: None ) \u2013 a dictionary that maps outcomes of the state to names of a state in this state machine. reset () Resets the state-machine. Ensures that the next call will start again from the starting state. Calls reset on all the states it contains. set_start_state ( name ) Explicitly states the starting state. States are specified using their name Parameters: name ( str ) \u2013 set the state by which the state machine starts. By default the first state added.","title":"TickingStateMachine"},{"location":"tickingstatemachine/#betfsm.betfsm.TickingStateMachine","text":"Bases: TickingState A StateMachine that calls a callback function before entering a state and/or at each transition. This statemachine is capable of working together with TickingState: will exit when TICKING outcome is given by one of the substates, but then if it is called again, it will have remembered the state that had the TICKING outcome and start from that state. if returning with any other outcome, will start next time from the start state. should be drop in replacement of Yasmin StateMachine, (but not the other way around, StateMachine can't handle TickingStates","title":"TickingStateMachine"},{"location":"tickingstatemachine/#betfsm.betfsm.TickingStateMachine.__init__","text":"TickintStatemachine is a statemachine that can maintain TickingStates. Parameters: name ( str ) \u2013 (instance) name of the state machine outcomes ( List [ str ] ) \u2013 the allowed outcomes of the state machine, any outcome not specified in transitions will be an outcome of the state machine and should be contained in outcomes (otherwise exception+abort) transitioncb \u2013 callback function called at each transition. Signature transitioncb(source_state:str, transtion:str, target_state:str). See also statecb \u2013 callback function called before entering each state. Signature statecb(name)","title":"__init__"},{"location":"tickingstatemachine/#betfsm.betfsm.TickingStateMachine.accept","text":"accepts a visitor to go through all states of an hierarchy","title":"accept"},{"location":"tickingstatemachine/#betfsm.betfsm.TickingStateMachine.add_state","text":"add_state(state,transitions) adds a state and associates transitions in this state-machine with this state. Parameters: state ( TickingState ) \u2013 state to be added, it will be added under its name (i.e. state.name, as defined in TickingState) transitions ( Dict [ str , str ] , default: None ) \u2013 a dictionary that maps outcomes of the state to names of a state in this state machine.","title":"add_state"},{"location":"tickingstatemachine/#betfsm.betfsm.TickingStateMachine.reset","text":"Resets the state-machine. Ensures that the next call will start again from the starting state. Calls reset on all the states it contains.","title":"reset"},{"location":"tickingstatemachine/#betfsm.betfsm.TickingStateMachine.set_start_state","text":"Explicitly states the starting state. States are specified using their name Parameters: name ( str ) \u2013 set the state by which the state machine starts. By default the first state added.","title":"set_start_state"},{"location":"timedrepeat/","text":"betfsm.betfsm_ros.TimedRepeat Bases: GeneratorWithState Repeats an underlying state for a given number of times and a given time interval. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state TimedRepeat { direction TB [*] --> my_state state \"State\" as my_state state \"Waiting\" as waiting my_state --> waiting : succeed waiting --> my_state : timeout } [*] --> TimedRepeat my_state --> SUCCEED : #succeed > maxcount my_state --> OTHER : other outcome my_state --> TICKING : ticking waiting --> TICKING : ticking waiting --> ABORT : time > timeout class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class ABORT abortClass __init__ ( name , maxcount , timeout , state , node = None ) TimedRepeat repeats the underlying state each timeout duration, until either the specified maxcount iterations is reached or the underlying state returns anything else besides TICKING or SUCCEED. TimedRepeat returns TICKING or finishes with SUCCEED if maxcount is reached, or another outcome if such outcome is returned by the underlying state. Parameters: name ( str ) \u2013 instance name maxcount ( int ) \u2013 maximum of iterations, if maxcount==0, repeat until SUCCEED is returned. timeout ( Duration ) \u2013 underlying state is triggered every timeout duration state ( TickingState ) \u2013 underlying state node ( Node , default: None ) \u2013 ROS2 node, if None, BeTFSMNode.get_instance() is used Note if the underlying state returns later than timeout with a non-ticking outcome, an exception will be raised and abort is called.","title":"TimedRepeat"},{"location":"timedrepeat/#betfsm.betfsm_ros.TimedRepeat","text":"Bases: GeneratorWithState Repeats an underlying state for a given number of times and a given time interval. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state TimedRepeat { direction TB [*] --> my_state state \"State\" as my_state state \"Waiting\" as waiting my_state --> waiting : succeed waiting --> my_state : timeout } [*] --> TimedRepeat my_state --> SUCCEED : #succeed > maxcount my_state --> OTHER : other outcome my_state --> TICKING : ticking waiting --> TICKING : ticking waiting --> ABORT : time > timeout class SUCCEED successClass class OTHER otherClass class TICKING tickingClass class ABORT abortClass","title":"TimedRepeat"},{"location":"timedrepeat/#betfsm.betfsm_ros.TimedRepeat.__init__","text":"TimedRepeat repeats the underlying state each timeout duration, until either the specified maxcount iterations is reached or the underlying state returns anything else besides TICKING or SUCCEED. TimedRepeat returns TICKING or finishes with SUCCEED if maxcount is reached, or another outcome if such outcome is returned by the underlying state. Parameters: name ( str ) \u2013 instance name maxcount ( int ) \u2013 maximum of iterations, if maxcount==0, repeat until SUCCEED is returned. timeout ( Duration ) \u2013 underlying state is triggered every timeout duration state ( TickingState ) \u2013 underlying state node ( Node , default: None ) \u2013 ROS2 node, if None, BeTFSMNode.get_instance() is used Note if the underlying state returns later than timeout with a non-ticking outcome, an exception will be raised and abort is called.","title":"__init__"},{"location":"timedwait/","text":"betfsm.betfsm_ros.TimedWait Bases: Generator Node that waits for a given time and then returns succeed stateDiagram-v2 direction LR classDef greenClass fill:darkgreen,color:white classDef yellowClass fill:yellow,color:black classDef redClass fill:darkred,color:white state \"TimedWait (timeout )\" as TimedWait [*] --> TimedWait TimedWait --> SUCCEED : timeout reached SUCCEED --> [*] TimedWait --> TICKING : ticking TICKING --> [*] class SUCCEED greenClass class TICKING yellowClass __init__ ( name , timeout = Duration ( seconds = 1.0 ), node = None ) TimedWait waits for a given time and then returns succeed. Parameters: name ( str ) \u2013 instance name timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 duration to wait. node ( Node , default: None ) \u2013 Node to use for clock, Returns: \u2013 will return TICKING until timeout is passed after which it returns SUCCEED","title":"TimedWait"},{"location":"timedwait/#betfsm.betfsm_ros.TimedWait","text":"Bases: Generator Node that waits for a given time and then returns succeed stateDiagram-v2 direction LR classDef greenClass fill:darkgreen,color:white classDef yellowClass fill:yellow,color:black classDef redClass fill:darkred,color:white state \"TimedWait (timeout )\" as TimedWait [*] --> TimedWait TimedWait --> SUCCEED : timeout reached SUCCEED --> [*] TimedWait --> TICKING : ticking TICKING --> [*] class SUCCEED greenClass class TICKING yellowClass","title":"TimedWait"},{"location":"timedwait/#betfsm.betfsm_ros.TimedWait.__init__","text":"TimedWait waits for a given time and then returns succeed. Parameters: name ( str ) \u2013 instance name timeout ( Duration , default: Duration (seconds=1.0) ) \u2013 duration to wait. node ( Node , default: None ) \u2013 Node to use for clock, Returns: \u2013 will return TICKING until timeout is passed after which it returns SUCCEED","title":"__init__"},{"location":"timeout/","text":"betfsm.betfsm_ros.Timeout Bases: GeneratorWithState Timeout __init__ ( name , timeout , state , node = None ) Timeout executes the underlying state at long as its outcome is TICKING. It finishes when the outcome is not ticking and returns this outcome. It also finishes when the given duration is exceeded and returns TIMEOUT. Parameters: name ( str ) \u2013 instance name timeout ( Duration ) \u2013 underlying state is triggered every timeout duration state ( TickingState ) \u2013 underlying state node ( Node , default: None ) \u2013 ROS2 node, if None, BeTFSMNode.get_instance() is used Warning assumes that the underlying state sufficiently yields TICKING! Don't use this if the underlying state completely blocks!","title":"Timeout"},{"location":"timeout/#betfsm.betfsm_ros.Timeout","text":"Bases: GeneratorWithState Timeout","title":"Timeout"},{"location":"timeout/#betfsm.betfsm_ros.Timeout.__init__","text":"Timeout executes the underlying state at long as its outcome is TICKING. It finishes when the outcome is not ticking and returns this outcome. It also finishes when the given duration is exceeded and returns TIMEOUT. Parameters: name ( str ) \u2013 instance name timeout ( Duration ) \u2013 underlying state is triggered every timeout duration state ( TickingState ) \u2013 underlying state node ( Node , default: None ) \u2013 ROS2 node, if None, BeTFSMNode.get_instance() is used Warning assumes that the underlying state sufficiently yields TICKING! Don't use this if the underlying state completely blocks!","title":"__init__"},{"location":"topicstate/","text":"::: betfsm.betfsm_ros.TopicState options: show_source: false show_root_heading: true","title":"TopicState"},{"location":"upanddown/","text":"Tutorial example \"Up & Down\" One needs to give permission for the devcontainer to display graphical windows on the host computer. These needs to be executed on the host computer, outside Visual Studio. xhost + To be checked if it also works (where local=localhost and root is users) xhost +local:root To retract the permissions: xhost - This test setup needs the following nodes running: RVIZ : visualization of UR10 robot: ros2 launch etasl_ros2_application_template load_ur10_setup.launch.py Running the eTaSL node : ros2 run etasl_ros2 etasl_node This will start up a server that can execute eTaSL. The example action server in this repository is run by: ros2 run betfsm_demos example_action_server You are now listening for incomming actions. A small script in the ./scripts directory calls an action handled by the example_action_server: ./scripts/send_up_and_down.sh Try interrupting the script with ctrl-C while its waiting to finish. You'll see that this is passed to the state-machine, that will also finish, this is done by checking a variable on the blackboard while running your statemachine. There are two examples that deal in a different way with cancelation of the action: example_action_server.py continuously checks for cancelation and interupts the robot motion by deactivating the eTaSL server. The example shows how to specify a shutdown procedure. example_action_server2.py uses a state to detect cancelation such that robot motion can be interrupted at a specified time. These examples also start a state that publishes the statemachine on a String topic in graphviz format. You can startup a webserver that publishes an svg file using: ros2 run betfsm web_server I you look at the action scripts, you see that a Concurrent state runs the state machine in parallel with a GraphvizPublisher state that publishes the state machine on a topic /gz . There is a do_not_expand_types and do_not_expand_instances argument where you can limit what is displayed in the state machine (in order not to overload the figure) Concurrent(\"concurrent\",[ sm, GraphvizPublisher(\"publisher\",\"/gz\",sm,None,skip=10,do_not_expand_types=[eTaSL_StateMachine]) TODO still some work here... in sm_up_and_down.py you find example statemachines that show different styles for specifying a simple state machine that moves up and down: Up & Down, specified as a function: Source code in betfsm_demos/sm_up_and_down.py 43 44 45 46 47 48 49 50 51 52 def up_and_down_as_a_function ( node = None ): \"\"\" \"\"\" return Sequence ( \"my_sequence\" , children = [ eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node ), eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ), eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node ), eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node ), Message ( \"Robot is finished\" ) ] ) options: heading_level: 3 show_source: true show_root_heading: true Up & Down, specified as a function and with a timer running concurrently: Source code in betfsm_demos/sm_up_and_down.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def up_and_down_as_a_function_and_a_timer ( node = None ): \"\"\" \"\"\" return ConcurrentSequence ( \"up_and_down_as_a_function\" , children = [ Sequence ( \"my_sequence\" , children = [ eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node ), eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ), eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node ), eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node ), Message ( \"Robot is finished\" ) ] ), Sequence ( \"timer\" , children = [ TimedWait ( \"timed_wait\" , Duration ( seconds = 3.0 ), node = node ), Message ( msg = \"Timer went off!\" ) ] ) ]) options: heading_level: 3 show_source: true show_root_heading: true Up & Down, specified as a class: Bases: Sequence Source code in betfsm_demos/sm_up_and_down.py 72 73 74 75 76 77 78 79 80 81 82 83 class Up_and_down_as_a_class ( Sequence ): \"\"\" \"\"\" def __init__ ( self , node = None ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) self . add_state ( eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( \"Hello world\" )) __init__ ( node = None ) Source code in betfsm_demos/sm_up_and_down.py 75 76 77 78 79 80 81 82 83 def __init__ ( self , node = None ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) self . add_state ( eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( \"Hello world\" )) options: heading_level: 3 show_source: true show_root_heading: true Up & Down, with eTaSL tasks with input and output parameters: Bases: Sequence Source code in betfsm_demos/sm_up_and_down.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Up_and_down_with_parameters ( Sequence ): def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) class MyComputations ( Generator ): def __init__ ( self ): super () . __init__ ( \"MyComputations\" ,[ SUCCEED ]) def co_execute ( self , bb ): bb [ \"home_computations\" ] = {} bb [ \"home_computations\" ][ \"joint_1\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 yield SUCCEED def my_parameters ( bb : Blackboard ) -> Dict : result = {} result [ \"joint_1\" ] = bb [ \"home_computations\" ][ \"joint_1\" ] result [ \"joint_2\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 return result self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( MyComputations () ) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = my_parameters , node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{ \"x_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"x_tcp\" ], \"y_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"y_tcp\" ], \"z_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"z_tcp\" ] })) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{})) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) ) __init__ ( node ) Source code in betfsm_demos/sm_up_and_down.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) class MyComputations ( Generator ): def __init__ ( self ): super () . __init__ ( \"MyComputations\" ,[ SUCCEED ]) def co_execute ( self , bb ): bb [ \"home_computations\" ] = {} bb [ \"home_computations\" ][ \"joint_1\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 yield SUCCEED def my_parameters ( bb : Blackboard ) -> Dict : result = {} result [ \"joint_1\" ] = bb [ \"home_computations\" ][ \"joint_1\" ] result [ \"joint_2\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 return result self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( MyComputations () ) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = my_parameters , node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{ \"x_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"x_tcp\" ], \"y_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"y_tcp\" ], \"z_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"z_tcp\" ] })) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{})) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) ) options: heading_level: 3 show_source: true show_root_heading: true Up & Down, with eTaSL tasks with input and output parameters using lambda functions: Bases: Sequence Source code in betfsm_demos/sm_up_and_down.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class Up_and_down_with_parameters_lambda ( Sequence ): def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_with_parameters_lambda\" ) self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( Compute ( \"compute_state\" ,[ \"home_computations\" ], lambda bb : { \"joint_1\" : bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 } )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = lambda bb : { \"joint_1\" : bb [ \"home_computations\" ][ \"joint_1\" ], \"joint_2\" : bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 , }, node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) ) __init__ ( node ) Source code in betfsm_demos/sm_up_and_down.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_with_parameters_lambda\" ) self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( Compute ( \"compute_state\" ,[ \"home_computations\" ], lambda bb : { \"joint_1\" : bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 } )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = lambda bb : { \"joint_1\" : bb [ \"home_computations\" ][ \"joint_1\" ], \"joint_2\" : bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 , }, node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) ) options: heading_level: 3 show_source: true show_root_heading: true","title":"Up & Down"},{"location":"upanddown/#tutorial-example-up-down","text":"One needs to give permission for the devcontainer to display graphical windows on the host computer. These needs to be executed on the host computer, outside Visual Studio. xhost + To be checked if it also works (where local=localhost and root is users) xhost +local:root To retract the permissions: xhost - This test setup needs the following nodes running: RVIZ : visualization of UR10 robot: ros2 launch etasl_ros2_application_template load_ur10_setup.launch.py Running the eTaSL node : ros2 run etasl_ros2 etasl_node This will start up a server that can execute eTaSL. The example action server in this repository is run by: ros2 run betfsm_demos example_action_server You are now listening for incomming actions. A small script in the ./scripts directory calls an action handled by the example_action_server: ./scripts/send_up_and_down.sh Try interrupting the script with ctrl-C while its waiting to finish. You'll see that this is passed to the state-machine, that will also finish, this is done by checking a variable on the blackboard while running your statemachine. There are two examples that deal in a different way with cancelation of the action: example_action_server.py continuously checks for cancelation and interupts the robot motion by deactivating the eTaSL server. The example shows how to specify a shutdown procedure. example_action_server2.py uses a state to detect cancelation such that robot motion can be interrupted at a specified time. These examples also start a state that publishes the statemachine on a String topic in graphviz format. You can startup a webserver that publishes an svg file using: ros2 run betfsm web_server I you look at the action scripts, you see that a Concurrent state runs the state machine in parallel with a GraphvizPublisher state that publishes the state machine on a topic /gz . There is a do_not_expand_types and do_not_expand_instances argument where you can limit what is displayed in the state machine (in order not to overload the figure) Concurrent(\"concurrent\",[ sm, GraphvizPublisher(\"publisher\",\"/gz\",sm,None,skip=10,do_not_expand_types=[eTaSL_StateMachine]) TODO still some work here... in sm_up_and_down.py you find example statemachines that show different styles for specifying a simple state machine that moves up and down:","title":"Tutorial example \"Up &amp; Down\""},{"location":"upanddown/#up-down-specified-as-a-function","text":"Source code in betfsm_demos/sm_up_and_down.py 43 44 45 46 47 48 49 50 51 52 def up_and_down_as_a_function ( node = None ): \"\"\" \"\"\" return Sequence ( \"my_sequence\" , children = [ eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node ), eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ), eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node ), eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node ), Message ( \"Robot is finished\" ) ] ) options: heading_level: 3 show_source: true show_root_heading: true","title":"Up &amp; Down, specified as a function:"},{"location":"upanddown/#up-down-specified-as-a-function-and-with-a-timer-running-concurrently","text":"Source code in betfsm_demos/sm_up_and_down.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 def up_and_down_as_a_function_and_a_timer ( node = None ): \"\"\" \"\"\" return ConcurrentSequence ( \"up_and_down_as_a_function\" , children = [ Sequence ( \"my_sequence\" , children = [ eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node ), eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ), eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node ), eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node ), Message ( \"Robot is finished\" ) ] ), Sequence ( \"timer\" , children = [ TimedWait ( \"timed_wait\" , Duration ( seconds = 3.0 ), node = node ), Message ( msg = \"Timer went off!\" ) ] ) ]) options: heading_level: 3 show_source: true show_root_heading: true","title":"Up &amp; Down, specified as a function and with a timer running concurrently:"},{"location":"upanddown/#up-down-specified-as-a-class","text":"Bases: Sequence Source code in betfsm_demos/sm_up_and_down.py 72 73 74 75 76 77 78 79 80 81 82 83 class Up_and_down_as_a_class ( Sequence ): \"\"\" \"\"\" def __init__ ( self , node = None ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) self . add_state ( eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( \"Hello world\" ))","title":"Up &amp; Down, specified as a class:"},{"location":"upanddown/#betfsm_demos.sm_up_and_down.Up_and_down_as_a_class.__init__","text":"Source code in betfsm_demos/sm_up_and_down.py 75 76 77 78 79 80 81 82 83 def __init__ ( self , node = None ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) self . add_state ( eTaSL_StateMachine ( \"movinghome\" , \"MovingHome\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( \"Hello world\" )) options: heading_level: 3 show_source: true show_root_heading: true","title":"__init__"},{"location":"upanddown/#up-down-with-etasl-tasks-with-input-and-output-parameters","text":"Bases: Sequence Source code in betfsm_demos/sm_up_and_down.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 class Up_and_down_with_parameters ( Sequence ): def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) class MyComputations ( Generator ): def __init__ ( self ): super () . __init__ ( \"MyComputations\" ,[ SUCCEED ]) def co_execute ( self , bb ): bb [ \"home_computations\" ] = {} bb [ \"home_computations\" ][ \"joint_1\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 yield SUCCEED def my_parameters ( bb : Blackboard ) -> Dict : result = {} result [ \"joint_1\" ] = bb [ \"home_computations\" ][ \"joint_1\" ] result [ \"joint_2\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 return result self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( MyComputations () ) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = my_parameters , node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{ \"x_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"x_tcp\" ], \"y_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"y_tcp\" ], \"z_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"z_tcp\" ] })) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{})) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) )","title":"Up &amp; Down, with eTaSL tasks with input and output parameters:"},{"location":"upanddown/#betfsm_demos.sm_up_and_down.Up_and_down_with_parameters.__init__","text":"Source code in betfsm_demos/sm_up_and_down.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_as_a_class\" ) class MyComputations ( Generator ): def __init__ ( self ): super () . __init__ ( \"MyComputations\" ,[ SUCCEED ]) def co_execute ( self , bb ): bb [ \"home_computations\" ] = {} bb [ \"home_computations\" ][ \"joint_1\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 yield SUCCEED def my_parameters ( bb : Blackboard ) -> Dict : result = {} result [ \"joint_1\" ] = bb [ \"home_computations\" ][ \"joint_1\" ] result [ \"joint_2\" ] = bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 return result self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( MyComputations () ) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = my_parameters , node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{ \"x_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"x_tcp\" ], \"y_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"y_tcp\" ], \"z_tcp\" : bb [ \"output\" ][ \"movingup\" ][ \"z_tcp\" ] })) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( FeedbackState ( \"feedback1\" , \"up\" , lambda bb :{})) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) ) options: heading_level: 3 show_source: true show_root_heading: true","title":"__init__"},{"location":"upanddown/#up-down-with-etasl-tasks-with-input-and-output-parameters-using-lambda-functions","text":"Bases: Sequence Source code in betfsm_demos/sm_up_and_down.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 class Up_and_down_with_parameters_lambda ( Sequence ): def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_with_parameters_lambda\" ) self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( Compute ( \"compute_state\" ,[ \"home_computations\" ], lambda bb : { \"joint_1\" : bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 } )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = lambda bb : { \"joint_1\" : bb [ \"home_computations\" ][ \"joint_1\" ], \"joint_2\" : bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 , }, node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) )","title":"Up &amp; Down, with eTaSL tasks with input and output parameters using lambda functions:"},{"location":"upanddown/#betfsm_demos.sm_up_and_down.Up_and_down_with_parameters_lambda.__init__","text":"Source code in betfsm_demos/sm_up_and_down.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def __init__ ( self , node ): \"\"\" \"\"\" super () . __init__ ( \"Up_and_down_with_parameters_lambda\" ) self . add_state ( eTaSL_StateMachine ( \"home1\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"output\" ])) self . add_state ( Compute ( \"compute_state\" ,[ \"home_computations\" ], lambda bb : { \"joint_1\" : bb [ \"output\" ][ \"home1\" ][ \"jpos1\" ] * 180.0 / math . pi + 100.0 } )) self . add_state ( LogBlackboard ( \"LogBlackboard1\" ,[ \"home_computations\" ])) self . add_state ( eTaSL_StateMachine ( \"home2\" , \"MovingHome\" , cb = lambda bb : { \"joint_1\" : bb [ \"home_computations\" ][ \"joint_1\" ], \"joint_2\" : bb [ \"output\" ][ \"home1\" ][ \"jpos2\" ] * 180.0 / math . pi + 5 , }, node = node ) ) self . add_state ( eTaSL_StateMachine ( \"home3\" , \"MovingHome\" , node = node )) self . add_state ( LogBlackboard ( \"Logblackboard2\" ,[ \"output\" ] )) self . add_state ( eTaSL_StateMachine ( \"movingup\" , \"MovingUp\" , node = node ),) self . add_state ( eTaSL_StateMachine ( \"movingdown\" , \"MovingDown\" , node = node )) self . add_state ( eTaSL_StateMachine ( \"movingup2\" , \"MovingUp\" , node = node )) self . add_state ( Message ( msg = \"Hello world\" ) ) options: heading_level: 3 show_source: true show_root_heading: true","title":"__init__"},{"location":"utils/","text":"Utilities Logging Logging is implemented in logging.py . Some logging mechanism is foreseen between this library and the logging routines of ROS2. This allows us to do two things: logging to console when ROS2 is not present. offer some granularity with logging classes by using categories. Code that logs gets a log object by specifying a category. Uses can set the logger that belongs to a category. Example of categories are default , state (logging entering and leaving of each state), service (logging of service calls to ROS2) See the documentation of set_logger() below. For example, your main could contain: set_logger(\"default\",my_node.get_logger()) set_logger(\"service\",my_node.get_logger()) set_logger(\"state\",my_node.get_logger()) This sets the ROS2 logger for all of the above categories. Utility functions betfsm . betfsm_ros . expand_package_ref ( pth ) expands all occurencies of $PACKAGENAME] to the ROS2 packages they refer to. Parameters: pth ( str ) \u2013 string to expand betfsm . betfsm_ros . expand_env_ref ( pth ) expands all occurencies of $[ENVVAR] or $ENVVAR to the ROS2 packages they refer to. Parameters: pth: string to expand betfsm . betfsm_ros . expand_ref ( pth ) Expands both package references and environment variables. Parameters: pth ( str ) \u2013 string to expand betfsm . logger . set_logger ( category , logger ) Use this to set the logger, either LogPrinter() or ROS2node.get_logger() Parameters: category ( str ) \u2013 arbitrary name. You can associate a specific LogPrinter to a name, You probably want to specify at least the \"default\" logger (if not LogPrinter() is used, i.e. to Console) logger \u2013 Logger to associate with this category. Note Known categories used in betfsm_etasl: unknown (used when the category is not known or specified) default state (entering/exiting states, with outcome) default_loggers={\"default\":LogPrinter(),\"unknown\":DummyLogPrinter()} Note Loggers: ROS2 logger , i.e. node.get_logger() Logprinter() , i.e. prints to console DummyLogPrinter (), i.e. does nothing betfsm . logger . get_logger ( category = 'default' ) Use this to get a logger Parameters: category ( str , default: 'default' ) \u2013 arbitrary name. You can associate a specific LogPrinter to a name, if not specified, \"default\" is used. Note Known categories used in betfsm_etasl: unknown (used when the category is not known or specified) default state (entering/exiting states, with outcome) betfsm . betfsm . cleanup_outcomes ( outcomes ) cleans up a list of outcomes by elliminating duplicates. Returns: List [ str ] \u2013 list of outcomes with duplicate elements elliminated. betfsm . betfsm_ros . dumps_blackboard ( blackboard , indent = 0 ) returns a string-dump of a (piece of the ) blackboard Parameters: blackboard \u2013 indent \u2013 determines the indentation for printing.","title":"Utilities"},{"location":"utils/#utilities","text":"","title":"Utilities"},{"location":"utils/#logging","text":"Logging is implemented in logging.py . Some logging mechanism is foreseen between this library and the logging routines of ROS2. This allows us to do two things: logging to console when ROS2 is not present. offer some granularity with logging classes by using categories. Code that logs gets a log object by specifying a category. Uses can set the logger that belongs to a category. Example of categories are default , state (logging entering and leaving of each state), service (logging of service calls to ROS2) See the documentation of set_logger() below. For example, your main could contain: set_logger(\"default\",my_node.get_logger()) set_logger(\"service\",my_node.get_logger()) set_logger(\"state\",my_node.get_logger()) This sets the ROS2 logger for all of the above categories.","title":"Logging"},{"location":"utils/#utility-functions","text":"","title":"Utility functions"},{"location":"utils/#betfsm.betfsm_ros.expand_package_ref","text":"expands all occurencies of $PACKAGENAME] to the ROS2 packages they refer to. Parameters: pth ( str ) \u2013 string to expand","title":"expand_package_ref"},{"location":"utils/#betfsm.betfsm_ros.expand_env_ref","text":"expands all occurencies of $[ENVVAR] or $ENVVAR to the ROS2 packages they refer to. Parameters: pth: string to expand","title":"expand_env_ref"},{"location":"utils/#betfsm.betfsm_ros.expand_ref","text":"Expands both package references and environment variables. Parameters: pth ( str ) \u2013 string to expand","title":"expand_ref"},{"location":"utils/#betfsm.logger.set_logger","text":"Use this to set the logger, either LogPrinter() or ROS2node.get_logger() Parameters: category ( str ) \u2013 arbitrary name. You can associate a specific LogPrinter to a name, You probably want to specify at least the \"default\" logger (if not LogPrinter() is used, i.e. to Console) logger \u2013 Logger to associate with this category. Note Known categories used in betfsm_etasl: unknown (used when the category is not known or specified) default state (entering/exiting states, with outcome) default_loggers={\"default\":LogPrinter(),\"unknown\":DummyLogPrinter()} Note Loggers: ROS2 logger , i.e. node.get_logger() Logprinter() , i.e. prints to console DummyLogPrinter (), i.e. does nothing","title":"set_logger"},{"location":"utils/#betfsm.logger.get_logger","text":"Use this to get a logger Parameters: category ( str , default: 'default' ) \u2013 arbitrary name. You can associate a specific LogPrinter to a name, if not specified, \"default\" is used. Note Known categories used in betfsm_etasl: unknown (used when the category is not known or specified) default state (entering/exiting states, with outcome)","title":"get_logger"},{"location":"utils/#betfsm.betfsm.cleanup_outcomes","text":"cleans up a list of outcomes by elliminating duplicates. Returns: List [ str ] \u2013 list of outcomes with duplicate elements elliminated.","title":"cleanup_outcomes"},{"location":"utils/#betfsm.betfsm_ros.dumps_blackboard","text":"returns a string-dump of a (piece of the ) blackboard Parameters: blackboard \u2013 indent \u2013 determines the indentation for printing.","title":"dumps_blackboard"},{"location":"visitor/","text":"betfsm.betfsm.Visitor Bases: ABC Visitor pattern. Called by accept() methods of TickingState and its subclasses. The Visitor is a base class that you can inherit from to have your object called throughout the hierarchy of states. This mechanism is completely generic. See also Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison Wesley. (Gang of Four book) wikipedia post ( state ) Processing done by the visitor after visiting the children. returns nothing. pre ( state ) abstractmethod Processing done by visitor before visiting the children of the state. returns true if children needs to be explored","title":"Visitor"},{"location":"visitor/#betfsm.betfsm.Visitor","text":"Bases: ABC Visitor pattern. Called by accept() methods of TickingState and its subclasses. The Visitor is a base class that you can inherit from to have your object called throughout the hierarchy of states. This mechanism is completely generic. See also Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides (1994). Design Patterns: Elements of Reusable Object-Oriented Software. Addison Wesley. (Gang of Four book) wikipedia","title":"Visitor"},{"location":"visitor/#betfsm.betfsm.Visitor.post","text":"Processing done by the visitor after visiting the children. returns nothing.","title":"post"},{"location":"visitor/#betfsm.betfsm.Visitor.pre","text":"Processing done by visitor before visiting the children of the state. returns true if children needs to be explored","title":"pre"},{"location":"waitfor/","text":"betfsm.betfsm.WaitFor Bases: Generator A state that delays until a condition is satisfied. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state \"WaitFor\" as waitfor [*] --> waitfor waitfor --> TICKING : condition_cb()==False waitfor --> SUCCEED : condition_cb()==True class SUCCEED successClass class TICKING tickingClass __init__ ( condition_cb ) Ticks until condition is True and returns SUCCEED. Parameters: condition_cb \u2013 callback function with signature condition(blackboard:Blackboard) -> bool","title":"WaitFor"},{"location":"waitfor/#betfsm.betfsm.WaitFor","text":"Bases: Generator A state that delays until a condition is satisfied. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state \"WaitFor\" as waitfor [*] --> waitfor waitfor --> TICKING : condition_cb()==False waitfor --> SUCCEED : condition_cb()==True class SUCCEED successClass class TICKING tickingClass","title":"WaitFor"},{"location":"waitfor/#betfsm.betfsm.WaitFor.__init__","text":"Ticks until condition is True and returns SUCCEED. Parameters: condition_cb \u2013 callback function with signature condition(blackboard:Blackboard) -> bool","title":"__init__"},{"location":"waitforever/","text":"betfsm.betfsm.WaitForever Bases: Generator A state that waits forever (while yielding TICKING) __init__ () Ticks forever, yielding TICKING","title":"WaitForever"},{"location":"waitforever/#betfsm.betfsm.WaitForever","text":"Bases: Generator A state that waits forever (while yielding TICKING)","title":"WaitForever"},{"location":"waitforever/#betfsm.betfsm.WaitForever.__init__","text":"Ticks forever, yielding TICKING","title":"__init__"},{"location":"while/","text":"betfsm.betfsm.While Bases: GeneratorWithState State that contiuously evaluates an underlying state as long as a condition is satisfied. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state ConditionWhile { direction TB [*] --> my_state state \"State\" as my_state } [*] --> ConditionWhile my_state --> OTHER : other outcome my_state --> TICKING : ticking<br>condition_cb()==True my_state --> CANCEL : condition_cb()==False class OTHER otherClass class TICKING tickingClass class CANCEL abortClass __init__ ( name , condition_cb , state ) Same behavior as the underlying state state , but returns CANCEL if condition_cb(self,condition_cb) ever gets false. Parameters: name ( str ) \u2013 name of the instance condition_cb ( Callable ) \u2013 callback function with signature condition(blackboard:Blackboard) -> bool state ( TickingState ) \u2013 at each tick of the underlying state, the condition_cb is checked","title":"While"},{"location":"while/#betfsm.betfsm.While","text":"Bases: GeneratorWithState State that contiuously evaluates an underlying state as long as a condition is satisfied. stateDiagram-v2 direction LR classDef successClass fill:darkgreen,color:white classDef tickingClass fill:yellow,color:black classDef otherClass fill:darkorange,color:white classDef abortClass fill:darkred,color:white state ConditionWhile { direction TB [*] --> my_state state \"State\" as my_state } [*] --> ConditionWhile my_state --> OTHER : other outcome my_state --> TICKING : ticking<br>condition_cb()==True my_state --> CANCEL : condition_cb()==False class OTHER otherClass class TICKING tickingClass class CANCEL abortClass","title":"While"},{"location":"while/#betfsm.betfsm.While.__init__","text":"Same behavior as the underlying state state , but returns CANCEL if condition_cb(self,condition_cb) ever gets false. Parameters: name ( str ) \u2013 name of the instance condition_cb ( Callable ) \u2013 callback function with signature condition(blackboard:Blackboard) -> bool state ( TickingState ) \u2013 at each tick of the underlying state, the condition_cb is checked","title":"__init__"}]}