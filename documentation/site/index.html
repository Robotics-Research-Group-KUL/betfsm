<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/><meta content="Erwin Aertbelien" name="author"/>
<link href="img/favicon.ico" rel="shortcut icon"/>
<title>Home - BeTFSM documentation</title>
<link href="css/theme.css" rel="stylesheet"/>
<link href="css/theme_extra.css" rel="stylesheet"/>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" rel="stylesheet"/>
<link href="assets/_mkdocstrings.css" rel="stylesheet"/>
<link href="css/mkdocstrings.css" rel="stylesheet"/>
<script>
        // Current page data
        var mkdocs_page_name = "Home";
        var mkdocs_page_input_path = "index.md";
        var mkdocs_page_url = null;
      </script>
<!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
</head>
<body class="wy-body-for-nav" role="document">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side stickynav" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search">
<a class="icon icon-home" href="."> BeTFSM documentation
        </a><div role="search">
<form action="./search.html" class="wy-form" id="rtd-search-form" method="get">
<input aria-label="Search docs" name="q" placeholder="Search docs" title="Type search term here" type="text"/>
</form>
</div>
</div>
<div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption"><span class="caption-text">Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal current" href="#">Home</a>
<ul class="current">
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="#summary-of-states-and-state-machines">Summary of states and state-machines</a>
<ul>
<li class="toctree-l3"><a class="reference internal" href="#the-state-machine-state">The state-machine state</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#behavior-tree-like-states">Behavior-tree like states</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#related-to-conditions">Related to conditions</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#related-to-output">Related to output</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#related-to-timing">Related to timing</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#related-to-ros-2-services-life-cycle-and-topics">Related to ROS 2 services, life cycle and topics</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#related-to-etasl">Related to eTaSL</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#defining-your-own-states">Defining your own states</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#facilitating-implementation-of-a-tickingstate">Facilitating implementation of a TickingState</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#action-server">Action server</a>
</li>
<li class="toctree-l3"><a class="reference internal" href="#action-client">Action client</a>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">Tutorials</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="upanddown/">Up &amp; Down</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">BeTFSM</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="tickingstate/">TickingState</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="tickingstatemachine/">TickingStateMachine</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="visitor/">Visitor</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="generator/">Generator</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="sequence/">Sequence</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrentsequence/">ConcurrentSequence</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="fallback/">Fallback</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrentfallback/">ConcurrentFallback</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="concurrent/">Concurrent</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="waitfor/">WaitFor</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="waitforever/">WaitForever</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="while/">While</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="repeat/">Repeat</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="message/">Message</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="logblackboard/">LogBlackboard</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="compute/">Compute</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="adapt/">Adapt</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal">BeTFSM ROS2</a>
<ul>
<li class="toctree-l2"><a class="reference internal" href="serviceclient/">ServiceClient</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="lifecycle/">LifeCycle</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="topicstate/">TopicState</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="timedrepeat/">TimedRepeat</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="timedwait/">TimedWait</a>
</li>
<li class="toctree-l2"><a class="reference internal" href="timeout/">Timeout</a>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="etaslstatemachine/">BeTFSM eTaSL</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="actionserver/">Action server</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="utils/">Utilities</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="about/">About</a>
</li>
<li class="toctree-l1"><a class="reference internal" href="TODO/">Todo list</a>
</li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="Mobile navigation menu" class="wy-nav-top" role="navigation">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href=".">BeTFSM documentation</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content"><div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a aria-label="Docs" class="icon icon-home" href="."></a></li>
<li class="breadcrumb-item">Documentation</li>
<li class="breadcrumb-item active">Home</li>
<li class="wy-breadcrumbs-aside">
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div class="section" itemprop="articleBody">
<h1 id="betfsm">BeTFSM</h1>
<p>Published under the GNU LESSER GENERAL PUBLIC LICENSE Version 3, 29 June 2007.</p>
<p>(c) 2024, KU Leuven, Department of Mechanical Engineering, ROB-Group: Erwin Aertbeliën, 
contributions of Federico Ulloa Rios and Santiago Iregui Rincon</p>
<p>
<a href="https://aiprism.eu/"><img align="left" alt="AI-PRISM Logo" src="./static/Ai-Prism_Logo_Horizontal.png" style="margin-right:15px;" width="250"/></a>
  This work was funded by the European Union’s Horizon 2020 research and innovation program 
  under <a href="https://aiprism.eu/">grant agreement No. 101058589 AI-Prism</a>
</p>
<h2 id="introduction">Introduction</h2>
<p>This is a library for "ticking" statemachines and behavior trees. In this
unified framework, discrete tasks can be specified with the modularity of
behavior trees and at the lower-level precise interaction can be specified
using state machines.
Each <a class="autorefs autorefs-internal" href="tickingstate/#betfsm.betfsm.TickingState" title="betfsm.betfsm.TickingState">TickingState</a> (see <a class="autorefs autorefs-internal" href="tickingstate/#betfsm.betfsm.TickingState" title="betfsm.betfsm.TickingState">API</a> for detailed definition) is defined by the following methods:</p>
<ul>
<li>
<p><strong>entry(self,blackboard:Blackboard)</strong>:
    executed when the state is entered</p>
</li>
<li>
<p><strong>doo(self,blackboard:Blackboard)</strong>:
    execute while the state is running.  The state can take a longer time
    but should regularly yield by returning TICKING. Is implemented by derived classes.</p>
</li>
<li><strong>exit(self)</strong>:
    is execute when the state exits, note that it does not has the blackboard as argument.
    Will even be called when the other methods return an exception. Is implemented by derived classes</li>
<li><strong>reset(self)</strong>:
    Resets the state (i.e. calls exit() when appropriate and ensures that the next time, entry() will be called)</li>
<li><strong>accept(self, visitor:Visitor)</strong>: calls the visitor that you pass as an argument and possibly iterates over
    its children, e.g. to generate a visual representation of the behavior tree.</li>
</ul>
<p>There is an additional <strong>execute</strong> member function that typically should not be touched.</p>
<div class="admonition error">
<p class="admonition-title">WARNING</p>
<p>A TickingState is low-overhead and synchronous. It is expected to return quickly, and 
if further processing is needed to return TICK. If there is code in <strong>doo</strong> and <strong>entry</strong> that blocks,
the execution of the whole BeTFSM tree blocks, including concurrent TickingStates.  For blocking code,
the TickingState should create its own thread. </p>
</div>
<div class="mermaid">---
title: Internal workings of TickingState
---
stateDiagram-v2
   direction LR
   classDef successClass  fill:darkgreen,color:white
   classDef tickingClass  fill:yellow,color:black
   classDef otherClass  fill:darkorange,color:white
   classDef abortClass  fill:darkred,color:white
   classDef centerClass  text-align:center

entry --&gt; doo : returns &lt;br&gt;CONTINUE or TICK
doo --&gt; doo: returns&lt;br&gt;TICK
doo --&gt; exit : returns not TICK

entry --&gt;exit: returns &lt;br&gt;not TICK or CONTINUE
exit  --&gt; entry : exit() finished &lt;br&gt; or reset() called
doo --&gt; exit : reset() called

entry: calls entry()&lt;br&gt;if TICK return TICK&lt;br&gt;if exception return ABORT
doo:   calls doo()&lt;br&gt; if TICK return TICK &lt;br&gt;if exception return ABORT
exit:  calls exit()&lt;br&gt; return outcome&lt;br&gt;if exception return ABORT

class entry centerClass
</div>
<p>When using the state one calls it with the () operator. This calls then the execute() method that calls the entry,doo,exit methods
appropriately, according to the figure above.</p>
<p>The <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> is used to be able to generically travers the hierarchy of states.
the <strong>accept</strong> method of a TickingState calls the visitor appropriately.  Visitor is defined  <a class="autorefs autorefs-internal" href="visitor/#betfsm.betfsm.Visitor" title="betfsm.betfsm.Visitor">here</a></p>
<div class="admonition blackboard">
<p class="admonition-title">Blackboard</p>
<p>All TickingStates can read and write from a common <strong>blackboard</strong> of type
<strong>Blackboard: TypeAlias = Dict[str, Dict|any]</strong>, i.e. a hierarchically
organized common storage where all TickingStates can update information or get
information from.</p>
</div>
<div class="admonition parameters">
<p class="admonition-title">Parameters</p>
<p>When defining new TickingStates, remember to distinguish between
construction-time (arguments given to constructor) and run-time (passed using a
certain location in the blackboard) parameters.  Typically the <strong>location</strong>
(not the value!) of the run-time parameters is passed as parameters to the
constructor, such that the TickingState is easily reusable in different applications.</p>
</div>
<h2 id="summary-of-states-and-state-machines">Summary of states and state-machines</h2>
<p>This section explains the basics of BeTFSM.  You find more detailed information in the sections BeTFSM, BeTFSM ROS2, BeTFSM eTaSL which contain a full API-documentation.</p>
<p>Sometimes states have underlying states, e.g. a state-machine or a sequence.  Typically they can be specfied in two ways:</p>
<ul>
<li>a list of children in the constructor. This is handy when the substates are also simple to construct.  If there is only one underlying state, the constructor argument is typically called <code>state</code>, if there are multiple underlying states, the constructor argument is typically called <code>children</code>.</li>
<li>by subclassing the state (e.g. Sequence), and calling <code>add_state()</code> in the constructor of this subclass.  This is handy when the definition of the substates is a bit more complex.</li>
</ul>
<p>In some cases, more information needs to be given and only the <code>add_state</code> approach is applicable (e.g. TickingStateMachine).</p>
<h3 id="the-state-machine-state">The state-machine state</h3>
<p><a class="autorefs autorefs-internal" href="tickingstatemachine/#betfsm.betfsm.TickingStateMachine" title="betfsm.betfsm.TickingStateMachine">TickingStateMachine</a> implements a basic state machine. You
can add nodes using <a class="autorefs autorefs-internal" href="tickingstatemachine/#betfsm.betfsm.TickingStateMachine.add_state" title="add_state(state, transitions=None)">add_state</a>.  In this call
you also specify the transitions between states.  These transitions are specified by mapping an outcome of the state to the name of one of the states in the state machine.  </p>
<p>The <a class="autorefs autorefs-internal" href="tickingstatemachine/#betfsm.betfsm.TickingStateMachine.__init__" title="__init__(name, outcomes, transitioncb=default_transitioncb, statecb=default_statecb)">constructor</a> takes a (<strong>instance</strong>) name of the state machine, its allowable outcomes and two optional callback functions <code>transitioncb</code> and <code>statecb</code>.
Default implementations of the callbacks are described in <a class="autorefs autorefs-internal" href="default_callbacks/#betfsm.betfsm.default_transitioncb" title="betfsm.betfsm.default_transitioncb(statemachine, blackboard, source, outcome)">default|_transition_cb</a> and <a class="autorefs autorefs-internal" href="default_callbacks/#betfsm.betfsm.default_statecb" title="betfsm.betfsm.default_statecb(statemachine, blackboard, state)">default_statecb</a>.</p>
<h3 id="behavior-tree-like-states">Behavior-tree like states</h3>
<p>The most important behavior-tree like states are <a class="autorefs autorefs-internal" href="sequence/#betfsm.betfsm.Sequence" title="betfsm.betfsm.Sequence">Sequence</a>,<a class="autorefs autorefs-internal" href="fallback/#betfsm.betfsm.Fallback" title="betfsm.betfsm.Fallback">Fallback</a>,
<a class="autorefs autorefs-internal" href="concurrentsequence/#betfsm.betfsm.ConcurrentSequence" title="betfsm.betfsm.ConcurrentSequence">ConcurrentSequence</a>,<a class="autorefs autorefs-internal" href="concurrentfallback/#betfsm.betfsm.ConcurrentFallback" title="betfsm.betfsm.ConcurrentFallback">ConcurrentFallback</a>, and <a class="autorefs autorefs-internal" href="repeat/#betfsm.betfsm.Repeat" title="betfsm.betfsm.Repeat">Repeat</a></p>
<p>The main difference is that for a typical behavior-tree implementation the outcomes can only be RUNNING, SUCCESS or FAILURE. Here, there can be more types of outcome.   The mapping to traditional behavior trees is explained below, detailed behavior is documented in the diagrams in the API-documentation.</p>
<ul>
<li>
<p><strong>Fallback</strong> (or <em>Any(success)</em>):   Implements a behaviortree-like Fallback node (concurrently executed):</p>
<ul>
<li>other outcome is success</li>
<li>CANCEL outcome is failure</li>
<li>TICKING outcome is running</li>
</ul>
<p>Finishes if <strong>any</strong> has success.  Success is defined by an outcome different from CANCEL.
In other words, success can be differentiated by different outcomes.</p>
</li>
<li>
<p><strong>Sequence</strong> (or <em>All(success)</em>). Implements a behaviortree-like Sequence node (concurrently executed):</p>
<ul>
<li>SUCCEED outcome is success,</li>
<li>any other outcome is failure</li>
<li>TICKING outcome is running</li>
</ul>
<p>Finishes if <strong>all</strong> have success. Success is defined by an outcome SUCCEED.
In other words, failure can be differentiated by different outcomes.</p>
</li>
</ul>
<p><a class="autorefs autorefs-internal" href="concurrentsequence/#betfsm.betfsm.ConcurrentSequence" title="betfsm.betfsm.ConcurrentSequence">ConcurrentSequence</a> and <a class="autorefs autorefs-internal" href="concurrentfallback/#betfsm.betfsm.ConcurrentFallback" title="betfsm.betfsm.ConcurrentFallback">ConcurrentFallback</a> are basically the same as <a class="autorefs autorefs-internal" href="sequence/#betfsm.betfsm.Sequence" title="betfsm.betfsm.Sequence">Sequence</a> and <a class="autorefs autorefs-internal" href="fallback/#betfsm.betfsm.Fallback" title="betfsm.betfsm.Fallback">Fallback</a> but execute concurrently: at each tick they go to their complete list of states and follow the logic of sequence or fallback. e.g. in a ConcurrentSequence the states are executed concurrently, but within one tick, they are executed in the order specified.</p>
<p><a class="autorefs autorefs-internal" href="concurrent/#betfsm.betfsm.Concurrent" title="betfsm.betfsm.Concurrent">Concurrent</a> executes also its children concurrently (calling them in sequence for each tick). Concurrent stops executing when any child returns any outcome different from TICKING. See <a class="autorefs autorefs-internal" href="concurrent/#betfsm.betfsm.Concurrent" title="betfsm.betfsm.Concurrent">API</a> for description fo detailed behavior.</p>
<p>The <strong>Repeat</strong> state has one underlying state and repeats this state for a given number of times.</p>
<h3 id="related-to-conditions">Related to conditions</h3>
<ul>
<li><a class="autorefs autorefs-internal" href="waitfor/#betfsm.betfsm.WaitFor" title="betfsm.betfsm.WaitFor">waitFor</a> waits until a condition is satisfied.  This condition is given by a callback.
   Note that this callback can be defined using Python's <a href="https://python-reference.readthedocs.io/en/latest/docs/operators/lambda.html">lambda</a></li>
<li><a class="autorefs autorefs-internal" href="waitforever/#betfsm.betfsm.WaitForever" title="betfsm.betfsm.WaitForever">WaitForever</a> waits forever, you probably want something to be running in parallel with this.</li>
<li><a class="autorefs autorefs-internal" href="while/#betfsm.betfsm.While" title="betfsm.betfsm.While">While</a> continues to execute the underlying state while checking the given condition. It finishes with CANCEL when the condition returns false, it finishes also when the underlying state finishes and returns the outcome of the underlying state.</li>
</ul>
<h3 id="related-to-output">Related to output</h3>
<ul>
<li>
<p><a class="autorefs autorefs-internal" href="message/#betfsm.betfsm.Message" title="betfsm.betfsm.Message">Message</a> is a state to quickly return send message to the log.
Its arguments are either a string or either a callback function.  Since the string is specified at
construction time, the callback function is handy when you want to return something depending on the actual state while running.  Python's <a href="https://python-reference.readthedocs.io/en/latest/docs/operators/lambda.html">lambda</a> could be useful to specify the callback.</p>
</li>
<li>
<p><a class="autorefs autorefs-internal" href="logblackboard/#betfsm.betfsm.LogBlackboard" title="betfsm.betfsm.LogBlackboard">LogBlackboard</a> logs the blackboard or a part of the blackboard.
The location to log is given by a list of strings.  </p>
</li>
</ul>
<p>Example:
   <code>LogBlackboard|(["output","move_home"])</code>
   Logs the content of the blackboard under <code>blackboard["output]["move_home"]</code></p>
<h3 id="related-to-timing">Related to timing</h3>
<ul>
<li><a class="autorefs autorefs-internal" href="timedwait/#betfsm.betfsm_ros.TimedWait" title="betfsm.betfsm_ros.TimedWait">TimedWait</a> waits for the given duration and returns SUCCEED.</li>
<li><a class="autorefs autorefs-internal" href="timedwait/#betfsm.betfsm_ros.TimedWait" title="betfsm.betfsm_ros.TimedWait">TimedRepeat</a> repeats the underlying state for a given number of time.  The time between two repetitions is specified.</li>
<li><a class="autorefs autorefs-internal" href="timeout/#betfsm.betfsm_ros.Timeout" title="betfsm.betfsm_ros.Timeout">Timeout</a> executes the underlying state at long as its outcome is TICKING. It finishes when the outcome is not ticking and returns this outcome.  It also finishes when the given duration is exceeded and returns TIMEOUT.</li>
</ul>
<h3 id="related-to-ros-2-services-life-cycle-and-topics">Related to ROS 2 services, life cycle and topics</h3>
<p>To manage file locations in a ROS2 environment a function <a class="autorefs autorefs-internal" href="utils/#betfsm.betfsm_ros.expand_ref" title="betfsm.betfsm_ros.expand_ref(pth)">expand_ref</a> is provided that expands references to ROS2 packages (or more preciselly ament packages) (using <code>$[packagename]</code>) or environmental variables (using <code>${environmental_variable}</code>)</p>
<ul>
<li>
<p><a class="autorefs autorefs-internal" href="serviceclient/#betfsm.betfsm_ros.ServiceClient" title="betfsm.betfsm_ros.ServiceClient">ServiceClient</a> creates a TickingState that calls a ROS2 service and generates an outcome when the service returns back. While waiting, it continues to tick. Subclasses need to implement two methods <code>fill_in_request</code> to fill in the service request, most probably using information from the blackboard, and <code>process_result</code> to process the result from the service request, most probably putting some information in the blackboard.</p>
</li>
<li>
<p><a class="autorefs autorefs-internal" href="lifecycle/#betfsm.betfsm_ros.LifeCycle" title="betfsm.betfsm_ros.LifeCycle">LifeCycle</a> manages the lifecycle of some other ROS2 node.
  The node is constructed with service_name, transition (see below), timeout and the transition is requested during execution of the state.
  See below for a simplified view of this lifecycle (transition states not included):</p>
</li>
</ul>
<div class="mermaid">    stateDiagram-v2
        direction LR
        classDef successClass  fill:darkgreen,color:white
        classDef tickingClass  fill:yellow,color:black
        classDef otherClass  fill:darkorange,color:white
        classDef abortClass  fill:darkred,color:white


        [*] --&gt; unconfigured
        unconfigured --&gt; inactive : CONFIGURE
        inactive --&gt; active : ACTIVATE
        inactive --&gt; unconfigured : CLEANUP
        inactive --&gt; finalized : INACTIVE_SHUTDOWN
        active --&gt; inactive : DEACTIVATE
        active --&gt; finalized : ACTIVE_SHUTDOWN
        unconfigured --&gt; finalized : UNCONFIGURED_SHUTDOWN
</div>
<p>These are the transtions that can be passed to a LifeCycle state:
    <code>python
        class Transition(Enum):
            CONFIGURE              = 1
            CLEANUP                = 2
            ACTIVATE               = 3
            DEACTIVATE             = 4
            UNCONFIGURED_SHUTDOWN  = 5
            INACTIVE_SHUTDOWN      = 6
            ACTIVE_SHUTDOWN        = 7</code></p>
<h3 id="related-to-etasl">Related to eTaSL</h3>
<h3 id="defining-your-own-states">Defining your own states</h3>
<p>To implement a TickingState, you have to implement:</p>
<ul>
<li><code>def entry(self, blackboard: Blackboard) -&gt; str</code>  called when execute() is called for the first time. returns an outcome but has one additional outcome CONTINUE that indicates its preference to directly call <code>doo()</code> after its return, without a tick.</li>
<li><code>def doo(self, blackboard: Blackboard) -&gt; str</code> called for the duration of the task, as long as you return TICKING</li>
<li><code>def exit(self) -&gt; str</code>: should call <code>return super().exit()</code> at the end, is guaranteed to be called after the last time that execute() was called.</li>
<li><code>def reset(self)-&gt;None:</code>  should call <code>super().exit()</code> at the end: to reset the state <em>and its children</em>.</li>
<li><code>def accept(self, visitor:Visitor)</code> calls <code>pre</code> on the visitor, calls accept(visitor) on all its children, and then calls <code>post</code> on the visitor.  </li>
</ul>
<p>Keep in mind that the <code>reset</code> and <code>accept</code> methods still need to be defined when the state has children (otherwise 
the default implementations are sufficient)</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Forgetting to implement these methods can lead to silent failures.  Even worse, the state will 
work the first time, but not the second time.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Outside code that repeately calls a state-machine has to call <code>reset</code> itself before calling the state-machine. This method
calls the reset method of all its children and calls the reset method of its superclass <code>TickingState</code></p>
</div>
<h3 id="facilitating-implementation-of-a-tickingstate">Facilitating implementation of a TickingState</h3>
<p>To facilitate the definition of tickingStates, you can use <a href="https://www.geeksforgeeks.org/generators-in-python/">Python generators</a>, for this 
the <a class="autorefs autorefs-internal" href="generator/#betfsm.betfsm.Generator" title="betfsm.betfsm.Generator">Generator</a> class is defined.  Generator is a generic TickingState that implements methods <strong>entry</strong>, <strong>doo</strong> and <strong>exit</strong>.<br/>
Users can define new TickingStates by defining the method <code>co_execute(self, blackboard:Blackboard)</code>.  This method is a co-routine and can regularly 
yield control using a <code>yield &lt;outcom&gt;</code> statement. This makes it easy to specify a TickingState.</p>
<p>For common usecases, further (generic) specializations are provided by:</p>
<ul>
<li><a class="autorefs autorefs-internal" href="generator/#betfsm.betfsm.GeneratorWithState" title="betfsm.betfsm.GeneratorWithState">GeneratorWithState</a> for a Generator with <strong>one</strong> child state </li>
<li>[GeneratorWithList][betfsm.betfsm.GeneratorWithLists]  for a Generator with <strong>a (ordered) list of</strong> childs. </li>
</ul>
<p>These implementations implement correctly <code>reset</code> and <code>accept</code> for you and manage the child nodes (TickingStates) of
your TickingState.  Most of the other nodes are implemented using these auxiliary classes.</p>
<div class="admonition recommendation">
<p class="admonition-title">Recommendation</p>
<p>Look at a few implementations such as <code>WaitFor</code>,<code>Repeat</code>, <code>Concurrent</code>.  This will help making your own nodes.
Often it is sufficient to implement the constructor and the co_execute(self,blackboard) method and yield when
you want to yield control to BeTFSM, and come back at the same location the next tick of BeTFSM.</p>
</div>
<h3 id="action-server">Action server</h3>
<p>There is also a ROS2 Action server provided that allows us to respond to ROS2 Actions.  This contains
also a generic parameter-passing mechanism with a JSON message string that in the black-board of BeTFSM.</p>
<h3 id="action-client">Action client</h3>
<p><strong>ActionClientBTFSM</strong> contains a Tickingstate that calls and action and generates an outcome when the action 
returns back.   While waiting it gets the response of the action.</p>
</div>
</div><footer>
<div aria-label="Footer Navigation" class="rst-footer-buttons" role="navigation">
<a class="btn btn-neutral float-right" href="upanddown/" title="Up &amp; Down">Next <span class="icon icon-circle-arrow-right"></span></a>
</div>
<hr/>
<div role="contentinfo">
<!-- Copyright etc -->
<p>LGPL-3.0-only</p>
</div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
</div>
</div>
</section>
</div>
<div aria-label="Versions" class="rst-versions" role="note">
<span class="rst-current-version" data-toggle="rst-current-version">
<span>
<a class="fa fa-code-fork" href="https://gitlab.kuleuven.be/rob-expressiongraphs/ros2/BeTFSM" style="color: #fcfcfc"> Gitlab</a>
</span>
<span><a href="upanddown/" style="color: #fcfcfc">Next »</a></span>
</span>
</div>
<script src="js/jquery-3.6.0.min.js"></script>
<script>var base_url = ".";</script>
<script src="js/theme_extra.js"></script>
<script src="js/theme.js"></script>
<script src="https://cdn.jsdelivr.net/gh/rod2ik/cdn@main/mkdocs/javascripts/mkdocs-graphviz.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
<script src="search/main.js"></script>
<script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>
<script type="module">import mermaid from "https://unpkg.com/mermaid@10.4.0/dist/mermaid.esm.min.mjs";
mermaid.initialize({});</script></body>
</html>
